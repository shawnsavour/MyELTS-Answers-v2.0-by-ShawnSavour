{"v":1,"data":[{"id":"d2","matchUrl":"https://myelt.heinle.com/ilrn/resource/resource.do#/*/*/*/activity/*","rules":[{"type":"fileOverride","match":"https://myelt.heinle.com/media/books/*/shell/1.0.43/shell.js","file":"/* cengage-html-engines v1.0.43 Shell v1.0.43 UTC 2016-06-09 14:09:07 */\r\n\r\nvar App = (function() {\r\n\r\n\t\"use strict\";\r\n\r\n\tfunction init() {\r\n\r\n\t\tApp.Shell.create();\r\n\t}\r\n\r\n\treturn {\r\n\t\tShell: {},\r\n\t\tModel: {},\r\n\t\tView: {},\r\n\t\tCollection: {},\r\n\t\tUtils: {},\r\n\t\tinit: init\r\n\t};\r\n\r\n}());\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\tApp.Shell.create = function() {\r\n\r\n\t\tvar loader;\r\n\t\tvar context;\r\n\t\tvar assets;\r\n\t\tvar requisites;\r\n\t\tvar engineModel;\r\n\t\tvar commonUIModel;\r\n\t\tvar consoleView;\r\n\t\tvar themeEditorView;\r\n\t\tvar stateEditorView;\r\n\r\n\t\tfunction init() {\r\n\r\n\t\t\tconsole.log(\"cengage engine shell init\");\r\n\r\n\t\t\t// Remove 300ms delay from click events on touch devices.\r\n\t\t\tFastClick.attach(document.body);\r\n\r\n\t\t\t// find application context\r\n\t\t\tif ($.getQueryString(\"embeddedID\") !== undefined) {\r\n\t\t\t\t// engine embedded inside another engine (e.g. progress test)\r\n\t\t\t\tcontext = new App.Shell.EmbeddedContext();\r\n\t\t\t} else if ($.getQueryString(\"did\") !== undefined) {\r\n\t\t\t\t// floe mode\r\n\t\t\t\tcontext = new App.Shell.FloeContext();\r\n\t\t\t} else if ($.getQueryString(\"activity\") !== undefined) {\r\n\t\t\t\t// bookshelf mode\r\n\t\t\t\tcontext = new App.Shell.BookshelfContext();\r\n\t\t\t} else {\r\n\t\t\t\t// myelt mode\r\n\t\t\t\tcontext = new App.Shell.MyEltContext();\r\n\t\t\t}\r\n\r\n\t\t\tcontext.init(function() {\r\n\r\n\t\t\t\tconsole.log(\"shell gets application context initialized\");\r\n\r\n\t\t\t\tloadAssets();\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadAssets() {\r\n\r\n\t\t\t// load inert assets such as configs and layouts\r\n\r\n\t\t\tcontext.log(\"load assets\");\r\n\t\t\tvar engineLayout = context.engineLayout;\r\n\t\t\tvar commonUILayout = engineLayout.substring(0, engineLayout.lastIndexOf(\"/\")) + \"/common-ui.html\";\r\n\t\t\tvar productDataPath = context.dataPath;\r\n\t\t\tif (context.productConfigDataPathOverride) {\r\n\t\t\t\t// a potential override (e.g. in the case of basebook usage)\r\n\t\t\t\tproductDataPath = context.productConfigDataPathOverride;\r\n\t\t\t}\r\n\r\n\t\t\tassets = {}; // will store loaded assets\r\n\r\n\t\t\tvar assetsList = [\r\n\t\t\t\t{\r\n\t\t\t\t\t// global application configuration\r\n\t\t\t\t\tid: \"config\",\r\n\t\t\t\t\turl: context.dataPath + \"config.json\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// application configuration specific to a particular product\r\n\t\t\t\t\tid: \"configProduct\",\r\n\t\t\t\t\turl: productDataPath + \"config\" + \"_\" + context.productType.toLowerCase() + \".json\",\r\n\t\t\t\t\toptional: true\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// jwplayer skin\r\n\t\t\t\t\tid: \"jwplayerSkin\",\r\n\t\t\t\t\turl: context.dataPath + \"myelt_media_skin.xml\",\r\n\t\t\t\t\tsettings: {\r\n\t\t\t\t\t\tdataType: \"text\"\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// myelt theme css template\r\n\t\t\t\t\tid: \"myeltTheme\",\r\n\t\t\t\t\turl: context.dataPath + \"myelt_theme.txt\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// html for common UI\r\n\t\t\t\t\tid: \"commonUILayout\",\r\n\t\t\t\t\turl: commonUILayout\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// html for engine UI\r\n\t\t\t\t\tid: \"engineLayout\",\r\n\t\t\t\t\turl: engineLayout\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// activity XML\r\n\t\t\t\t\tid: \"activityData\",\r\n\t\t\t\t\turl: context.activity + (context.isFloe ? \"?nocache=\" + (new Date().getTime()) : \"\"),\r\n\t\t\t\t\tsettings: {\r\n\t\t\t\t\t\tdataType: \"text\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t];\r\n\r\n\t\t\tloader = new App.Utils.AssetLoader(assetsList, buildConfig);\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildConfig() {\r\n\r\n\t\t\tassets = loader.assets;\r\n            // note config settings can lever context properties via templates\r\n\t\t\t// and also how the base config is merged with a potential per product config\r\n\r\n\t\t\tcontext.config = $.extend(true, processConfig(assets.config), processConfig(assets.configProduct));\r\n\r\n\t\t\tvar useMediaFromProduct = context.readConfigSetting(\"media.useMediaFromProduct\");\r\n\t\t\tif ($.getQueryString(\"useMediaFromProduct\")) {\r\n\t\t\t\tuseMediaFromProduct = $.getQueryString(\"useMediaFromProduct\");\r\n\t\t\t}\r\n\t\t\t// here we can redirect a product to use the media from a different product\r\n\t\t\tif (useMediaFromProduct) {\r\n\t\t\t\tcontext.changeProductMedia(useMediaFromProduct);\r\n\t\t\t}\r\n\r\n\t\t\tcontext.processConfig(); // a chance for context to do something with config\r\n\r\n\t\t\tloadLocale();\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadLocale() {\r\n\r\n\t\t\t// a way of adding translated text into the engines\r\n\t\t\t// currently this support is lightly used so the implementation is basic\r\n\r\n\t\t\tvar locale = context.readConfigSetting(context.engineClass.toLowerCase() + \".localization.lang\", \"\");\r\n\t\t\tif (!locale) {\r\n\t\t\t\tlocale = context.readConfigSetting(\"localization.lang\", \"en\");\r\n\t\t\t}\r\n\t\t\tif ($.getQueryString(\"locale\")) {\r\n\t\t\t\tlocale = $.getQueryString(\"locale\");\r\n\t\t\t}\r\n\t\t\tcontext.locale = locale;\r\n\r\n\t\t\tif (locale !== \"en\") {\r\n\t\t\t\tvar localizedAssetsList = [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: \"localizedCommonUILayout\",\r\n\t\t\t\t\t\turl: context.commonUILayout\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: \"localizedEngineLayout\",\r\n\t\t\t\t\t\turl: context.engineLayout\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t\t_.each(localizedAssetsList, function(asset, index) {\r\n\r\n\t\t\t\t\tvar parts = asset.url.split(\"/\");\r\n\t\t\t\t\tparts.splice(parts.length - 1, 0, \"locales\", locale);\r\n\t\t\t\t\tvar localizedLayoutPath = parts.join(\"/\");\r\n\t\t\t\t\tasset.url = localizedLayoutPath;\r\n\t\t\t\t\tasset.optional = true;\r\n\t\t\t\t});\r\n\t\t\t\tvar localeLoader = new App.Utils.AssetLoader(localizedAssetsList, function() {\r\n\t\t\t\t\t$.extend(assets, localeLoader.assets);\r\n\t\t\t\t\tloadEngine();\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tloadEngine();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction loadEngine() {\r\n\r\n\t\t\tif (context.readConfigSetting(\"settings.queryString.console\") === true) {\r\n\t\t\t\t// optional inline console can also be activated via config rather than query string\r\n\t\t\t\tshowInlineConsole();\r\n\t\t\t}\r\n\r\n\t\t\trequisites = [];\r\n\r\n\t\t\tif (App.Model[context.engineClass + \"Model\"] === undefined) {\r\n\r\n\t\t\t\t// may have already loaded engine code (e.g. via a test index or minified engines lib)\r\n\t\t\t\t// in that case we can skip the dynamic engine load\r\n\r\n\t\t\t\tvar engineBase = context.engine.split(\"/\").slice(0, -2).join(\"/\") + \"/\";\r\n\r\n\t\t\t\t// TODO load any additional libraries for engine now, these\r\n\t\t\t\t// will be specified in config.json\r\n\r\n\t\t\t\trequisites = [\r\n\t\t\t\t\t\tcontext.isDebug ? context.engine : context.engine.split(\".\").slice(0, -1).join(\".\") + \".min.js\",\r\n\t\t\t\t\t\tengineBase + \"css/\" + context.engineClass.toLowerCase() + (context.isDebug ? \"\" : \".min\") +  \".css\"\r\n\t\t\t\t];\r\n\t\t\t}\r\n\r\n\t\t\tif (!context.isMyElt) {\r\n\t\t\t\t$(\"head link\").each(function(i, el) {\r\n\t\t\t\t\tvar $link = $(this);\r\n\t\t\t\t\tif ($link.attr(\"data-delayed\") === \"true\") {\r\n\t\t\t\t\t\tvar href = $link.attr(\"href\");\r\n\t\t\t\t\t\tif (_.last(href.split(\".\")) === \"css\") {\r\n\t\t\t\t\t\t\trequisites.push(context.basePath + href);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (typeof delayedCss !== \"undefined\" && delayedCss !== undefined && delayedCss.length > 0) {\r\n\t\t\t\t\tfor (var i = 0; i < delayedCss.length; i++) {\r\n\t\t\t\t\t\trequisites.push(delayedCss[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (requisites.length > 0) {\r\n\t\t\t\tModernizr.load({\r\n\t\t\t\t\tload: requisites,\r\n\t\t\t\t\tcomplete: function() {\r\n\t\t\t\t\t\tengineLoaded();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tengineLoaded();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction engineLoaded() {\r\n\r\n\t\t\treplaceJWPlayerSkin(); // load skin directly to avoid skin load issue in mac bookshelf client\r\n\r\n\t\t\t/*\r\n\t\t\t * a liberty but jwplayer subtitle api did not allow this, we do not want to remember\r\n\t\t\t * subtitle on/off state between engines but do want to remember them within the engine\r\n\t\t\t */\r\n\t\t\tjwplayer.utils.saveCookie(\"captionLabel\", \"Off\");\r\n\r\n\t\t\tif (context.isMyElt) {\r\n\t\t\t\tif (typeof delayedCss !== \"undefined\" && delayedCss !== undefined && delayedCss.length > 0) {\r\n\t\t\t\t\tfor (var i = 0; i < delayedCss.length; i++) {\r\n\t\t\t\t\t\tvar index = i;\r\n\t\t\t\t\t\tcontext.adaptor.getCSSReMapUrls(delayedCss[i], function(delayedCssData) {\r\n\t\t\t\t\t\t// delayed sheets in myelt become inline so url paths need re-routing\r\n\t\t\t\t\t\tdelayedCssData = delayedCssData.replace(/\\.\\.\\//g, \"\");\r\n\t\t\t\t\t\tloadCssAsEmbedded(delayedCssData, \"vs-style-delayed-\" + index);\r\n\t\t\t\t\t\t// after the last delayed CSS is loaded, callback\r\n\t\t\t\t\t\tif (index === (delayedCss.length - 1)) {\r\n\t\t\t\t\t\t\tapplyTheme();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyTheme();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (context.isBookshelf) {\r\n\t\t\t\t\t// code injection by bookshelf can skew modernizer css insert point so fix it\r\n\t\t\t\t\t_.each(requisites, function(el) {\r\n\t\t\t\t\t\tvar $lastCss = $(\"head [rel=stylesheet]\").last();\r\n\t\t\t\t\t\tif (el.substr(el.lastIndexOf(\".\")) === \".css\") {\r\n\t\t\t\t\t\t\t$(\"head [href='\" + el + \"']\").insertAfter($lastCss);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tapplyTheme();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction applyTheme() {\r\n\r\n\t\t\t/*\r\n\t\t\t * This is applying the color values from the per book/product optional\r\n\t\t\t * config file into a css template which is appended to the document\r\n\t\t\t * the per book/product themes build on top of 'stock' themes\r\n\t\t\t */\r\n\r\n\t\t\tvar themeName = $.getQueryString(\"theme\");\r\n\t\t\tvar theme = context.readConfigSetting(\"themes.\" + (themeName ? themeName : \"defaultTheme\"));\r\n\t\t\tvar isStock = false;\r\n\t\t\tif (!theme) {\r\n\t\t\t\t// this is a stock theme\r\n\t\t\t\ttheme = context.readConfigSetting(\"themes.\" + context.gui);\r\n\t\t\t\tisStock = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (theme) {\r\n\t\t\t\tvar themes = [theme];\r\n\t\t\t\tif (!isStock && !theme.base) {\r\n\t\t\t\t\t// always build on top of stock to make sure all values are defined\r\n\t\t\t\t\ttheme.base = context.gui;\r\n\t\t\t\t}\r\n\t\t\t\tvar curTheme = theme;\r\n\t\t\t\twhile ((curTheme = context.readConfigSetting(\"themes.\" + curTheme.base))) {\r\n\t\t\t\t\tthemes.push(curTheme);\r\n\t\t\t\t}\r\n\t\t\t\tthemes.reverse();\r\n\t\t\t\ttheme = {\r\n\t\t\t\t\tvalues: {}\r\n\t\t\t\t};\r\n\t\t\t\tfor (var i = 0; i < themes.length; i++) {\r\n\t\t\t\t\t_.extend(theme.values, themes[i].values);\r\n\t\t\t\t}\r\n\t\t\t\tcontext.theme = theme.values;\r\n\t\t\t\tvar cssTheme = _.template(assets.myeltTheme, getThemeTemplateData());\r\n\t\t\t\tloadCssAsEmbedded(cssTheme, \"vs-inline-theme\");\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuildCommonUI();\r\n\t\t}\r\n\r\n\t\tfunction buildCommonUI() {\r\n\r\n\t\t\t// for flexibility styles can be passed via query string (e.g. popup glossary 'nochrome')\r\n\t\t\t// or from a config settings (e.g no-header)\r\n\t\t\tvar style = $.getQueryString(\"style\");\r\n\t\t\tvar configStyle = context.readConfigSetting(\"settings.style\", \"\");\r\n\t\t\tif (configStyle) {\r\n\t\t\t\tif (style) {\r\n\t\t\t\t\tstyle += \",\" + configStyle;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyle = configStyle;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (style) {\r\n\t\t\t\t_.each(style.split(\",\"), function(style) {\r\n\t\t\t\t\t$(\"#content\").addClass(style);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// setup shared glossary link system\r\n\r\n\t\t\tsetupGlossaryLinks();\r\n\r\n\t\t\t// setup shared word list link system\r\n\r\n\t\t\tsetupWordListLinks();\r\n\r\n\t\t\t// preprocess activity xml text (e.g. glossary links) and convert to xml object\r\n\r\n\t\t\tassets.activityData = $.parseXML(preprocessActivityData(assets.activityData));\r\n\r\n\t\t\t// template handling\r\n\r\n\t\t\tvar templates = assets.commonUILayout;\r\n\t\t\tif (assets.localizedCommonUILayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localizedCommonUILayout;\r\n\t\t\t}\r\n\t\t\ttemplates += \"\\n\" + assets.engineLayout;\r\n\t\t\tif (assets.localizedEngineLayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localizedEngineLayout;\r\n\t\t\t}\r\n\r\n\t\t\tif (assets.localeEngineLayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localeEngineLayout;\r\n\t\t\t}\r\n\r\n\t\t\tvar getTemplate = function(id, optional) {\r\n\t\t\t\tfunction _getTemplate(id, optional) {\r\n\t\t\t\t\tif (id.charAt(0) !== \"#\") {\r\n\t\t\t\t\t\tthrow(new Error(\"getTemplate function can only find templates by id\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tid = id.substring(1);\r\n\t\t\t\t\tvar regexp = new RegExp(\"<script type=\\\"text\\\\/template\\\" id=\\\"\" + id + \"\\\">[\\\\s\\\\S]*?<\\\\/script>\");\r\n\t\t\t\t\tvar matches = regexp.exec(templates);\r\n\t\t\t\t\tif (matches === null) {\r\n\t\t\t\t\t\tif (optional !== true) {\r\n\t\t\t\t\t\t\tthrow(new Error(\"Missing template with id \" + id));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar t = matches[0].replace(/<script.*>|<\\/script>/g, \"\");\r\n\t\t\t\t\tt = t.replace(/&nbsp;/gi, \"&#160;\"); // for xhtml\r\n\t\t\t\t\treturn t;\r\n\t\t\t\t}\r\n\t\t\t\tvar t;\r\n\t\t\t\tif (context.locale !== \"en\") {\r\n\t\t\t\t\t// if a localized version exists then use that\r\n\t\t\t\t\tt = _getTemplate(id + \"-\" + context.locale, true);\r\n\t\t\t\t}\r\n\t\t\t\tif (!t) {\r\n\t\t\t\t\tt = _getTemplate(id, optional);\r\n\t\t\t\t}\r\n\t\t\t\treturn t;\r\n\t\t\t};\r\n\r\n\t\t\t// allow easy access to context\r\n\t\t\tBackbone.Model.prototype.context = Backbone.View.prototype.context = context;\r\n\r\n\t\t\t// allow access to external text\r\n\t\t\tBackbone.Model.prototype.getTemplate = Backbone.View.prototype.getTemplate = getTemplate;\r\n\t\t\tBackbone.Collection.prototype.getTemplate = getTemplate;\r\n\r\n\t\t\t// add global events system\r\n\t\t\tBackbone.Model.prototype.appEvents = Backbone.View.prototype.appEvents = _.clone(Backbone.Events);\r\n\t\t\tBackbone.Model.prototype.getTemplate = getTemplate;\r\n\r\n\t\t\t// create inline theme editor if requested or by default in the special 'theme' preview engine\r\n\t\t\tif ($.getQueryString(\"theme-editor\") === \"true\" || context.engineClass === \"THEME\") {\r\n\t\t\t\tsetupThemeEditor();\r\n\t\t\t}\r\n\r\n\t\t\t// create state editor used for testing state load during development\r\n\t\t\tif ($.getQueryString(\"state-editor\") === \"true\" || context.isFloe) {\r\n\t\t\t\tsetupStateEditor();\r\n\t\t\t}\r\n\r\n\t\t\t// create common ui layer\r\n\t\t\tvar commonUITemplate = _.template(getTemplate(\"#common-ui-template\"));\r\n\r\n\t\t\tcommonUIModel = new App.Model.CommonUIModel();\r\n\r\n\t\t\tcommonUIModel.parseLayoutData(assets.activityData);\r\n            commonUIModel.parseConfigData(assets.config);      //parses config data to extract hasFlagEnabled attribute\r\n\r\n\t\t\t$(\"#content\").html(commonUITemplate(commonUIModel.toJSON()));\r\n\r\n\t\t\t// add control buttons for context type (optional per engine buttons can be added too)\r\n\t\t\tconsole.log(\"context.gui\" + context.gui);\r\n\t\t\tvar responseMode = $(assets.activityData).find(\"responseMode\").attr(\"value\");\r\n\t\t\tvar configResponseMode = context.readConfigSetting(\"settings.responseMode\");\r\n\t\t\tif (responseMode === configResponseMode) {\r\n\t\t\t\tcontext.gui = \"myelt-iwb\";\r\n\t\t\t\tcontext.isPresentationMode = true;\r\n\t\t\t}\r\n\t\t\tvar btnsID = \"#common-ui-\" + context.gui + (context.subgui ? \"-\" + context.subgui : \"\") + \"-btn-template\";\r\n\t\t\tvar btns = $(getTemplate(btnsID)).addClass(\"stock-btn\");\r\n\t\t\tvar customBtnsID = \"#\" + context.engineClass.toLowerCase() + \"-common-custom-buttons-template\";\r\n\t\t\tvar customBtns = $(getTemplate(customBtnsID, true)).addClass(\"custom-btn\");\r\n\t\t\tif (context.engineClass.toLowerCase() === \"concen\" || context.engineClass.toLowerCase() === \"tictac\" || context.engineClass.toLowerCase() === \"anskey\") {\r\n\t\t\t\t$(\"#content .control-btns\").append(customBtns);\r\n\t\t\t}else {\r\n\t\t\t\t$(\"#content .control-btns\").append(customBtns.add(btns));\r\n\t\t\t}\r\n\r\n\t\t\t//$(\"#content .control-btns\").append(customBtns.add(btns));\r\n\r\n\t\t\tvar commonUIView = new App.View.CommonUIView({\r\n\t\t\t\tmodel: commonUIModel\r\n\t\t\t});\r\n\t\t\tcommonUIModel.parseData(assets.activityData);\r\n\r\n\t\t\t// this makes ui visible in myelt, we need that to show \"load results?\" message\r\n\t\t\tcontext.initializationComplete();\r\n\r\n\t\t\tcontext.commonUIModel = commonUIModel;\r\n\r\n\t\t\t// note we need previous state before engine build\r\n\t\t\tcontext.load(contextLoaded);\r\n\r\n\t\t}\r\n\r\n\t\tfunction contextLoaded() {\r\n\r\n\t\t\tconsole.log(\"contextLoaded\");\r\n\r\n\t\t\tbuildEngine();\r\n\t\t}\r\n\r\n\r\n\t\tfunction buildEngine() {\r\n\r\n\t\t\t// allow gui variation based on context\r\n\t\t\t$(\"#content\").addClass(context.gui);\r\n\t\t\tif (context.subgui) {\r\n\t\t\t\t$(\"#content\").addClass(context.gui + \"-\" + context.subgui);\r\n\t\t\t}\r\n\r\n\t\t\t// scope some styles to low versions of IE so core styles (and QA) are not compromised\r\n\t\t\tvar vIE = App.Utils.getInternetExplorerVersion();\r\n\t\t\tif (vIE === 9 || vIE === 10) {\r\n\t\t\t\t$(\"#content\").addClass(\"IE\" + vIE);\r\n\t\t\t}\r\n\r\n\t\t\t// create engine layer\r\n\t\t\t$(\"#content\").addClass(context.engineClass.toLowerCase());\r\n\t\t\tvar engineClass = _.rest(context.engineID.split(\"_\"), 2).join().toUpperCase();\r\n\t\t\tengineModel = new App.Model[context.engineClass + \"Model\"]({}, {\r\n\t\t\t\tcommonUIModel: commonUIModel\r\n\t\t\t});\r\n\r\n\t\t\tcontext.setEngineModel(engineModel);\r\n\r\n\t\t\tvar engineView = new App.View[context.engineClass + \"View\"]({\r\n\t\t\t\tmodel: engineModel,\r\n\t\t\t\tel: \".engine\",\r\n\t\t\t\tcommonUIModel: commonUIModel\r\n\t\t\t});\r\n\t\t\tcommonUIModel.setEngine(engineModel);\r\n\r\n\t\t\tvar fontLoadStrategy = engineModel.getFontLoadStrategy();\r\n\t\t\tif (fontLoadStrategy.type === \"wait\") {\r\n\t\t\t\tvar fonts = [{name: \"lato\"}]; // TODO move to config\r\n\t\t\t\tvar fontLoadDetector = new App.Utils.FontLoadDetector($(\"body\"), fonts, function(status, item) {\r\n\t\t\t\t\tif (status !== \"font-load\") {\r\n\t\t\t\t\t\t// ignore individual font load events\r\n\t\t\t\t\t\t// wait for either all-fonts-loaded or an error, in any case just move on\r\n\t\t\t\t\t\tbuildActivity();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tbuildActivity();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction buildActivity() {\r\n\r\n\t\t\tengineModel.parseData(assets.activityData, context);\r\n        }\r\n        /*\r\n\t\t * local shell utilities\r\n\t\t */\r\n\r\n\t\tfunction loadCssAsEmbedded(cssData, styleId) {\r\n\r\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\t\t\tvar style = document.createElement(\"style\");\r\n\t\t\tstyle.type = \"text/css\";\r\n\t\t\tstyle.id = styleId;\r\n\t\t\tif (style.styleSheet) {\r\n\t\t\t\tstyle.styleSheet.cssText = cssData;\r\n\t\t\t} else {\r\n\t\t\t\tstyle.appendChild(document.createTextNode(cssData));\r\n\t\t\t}\r\n\t\t\thead.appendChild(style);\r\n\t\t}\r\n\r\n\t\tfunction processConfig(configData) {\r\n\r\n\t\t\t// sometimes a string sometimes an object depending on server mime types\r\n\t\t\tvar config = typeof(configData) === \"object\" ? JSON.stringify(configData) : configData;\r\n\r\n\t\t\tif (config === \"\") {\r\n\t\t\t\tconfig = \"{}\"; // mac bookshelf client will not parse empty string\r\n\t\t\t}\r\n\r\n\t\t\t// config can use context properties in a macro like way\r\n\t\t\tconfig = JSON.parse(_.template(config, context));\r\n\t\t\treturn config;\r\n\t\t}\r\n\r\n\t\tfunction showInlineConsole() {\r\n\r\n\t\t\tif (!consoleView) {\r\n\t\t\t\tconsoleView = new App.View.ConsoleView();\r\n\t\t\t\t$(\"body\").append(consoleView.render().el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction replaceJWPlayerSkin() {\r\n\r\n\t\t\t/*\r\n\t\t\t * this is a workaround because jwplayer fails to load external skins in mac\r\n\t\t\t * bookshelf client. We do the load and then make it the jwplayer default skin.\r\n\t\t\t * This is not an exposed API so watch out for changes in jwplayer. Plus side is\r\n\t\t\t * that it is shared amongst multiple player instances so things are a little leaner\r\n\t\t\t */\r\n\r\n\t\t\tjwplayer.html5.defaultskin = function() {\r\n\t\t\t\tthis.text = assets.jwplayerSkin;\r\n\t\t\t\tthis.xml = jwplayer.utils.parseXML(this.text);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction preprocessActivityData(data) {\r\n\r\n\t\t\t// a chance to adjust activity data\r\n\t\t\t// replace flash glossary link format with html version\r\n\t\t\tdata = data.replace(/&lt;a +href=\"event:.*?&lt;\\/a&gt;/gi, function(match) {\r\n\t\t\t\tmatch = match.replace(\"target=\\\"_blank\\\"\", \"\");\r\n\t\t\t\tmatch = match.replace(/href=\"event:\\sglossary.*?\"/, function(match) {\r\n\t\t\t\t\tvar term = $.trim(_.rest(match.split(\",\"), 1).join().slice(0, -1));\r\n\t\t\t\t\treturn \"href=\\\"javascript:App.showGlossary('\" + term + \"')\\\"\";\r\n\t\t\t\t});\r\n\r\n\t\t\t\tmatch = match.replace(/href=\"event:\\s?wordlist.*?\"/, function(match) {\r\n\t\t\t\t\tvar splitMatch = match.replace(/\\\"/g, \"\").split(\",\");\r\n\t\t\t\t\tvar category = $.trim(splitMatch[1]);\r\n\t\t\t\t\tvar word =  $.trim(splitMatch[2]);\r\n\t\t\t\t\treturn \"href=\\\"javascript:App.showWordList('\" + category + \"' , '\" + word + \"')\\\"\";\r\n\t\t\t\t});\r\n\t\t\t\treturn match;\r\n\t\t\t});\r\n            // add global events system\r\n\t\t\tBackbone.Model.prototype.appEvents = Backbone.View.prototype.appEvents = _.clone(Backbone.Events);\r\n            commonUIModel = new App.Model.CommonUIModel();\r\n            commonUIModel.parseConfigData(assets.config);\r\n            if (!commonUIModel.get(\"hasFlashEnabled\")) {\r\n                data = data.replace(/mp3/g, \"ogg\");\r\n            }\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction setupGlossaryLinks() {\r\n\t\t\tApp.showGlossary = function(term) {\r\n\t\t\t\t// vector global glossary popup links to commonUI\r\n\t\t\t\tBackbone.Model.prototype.appEvents.trigger(\"showGlossary\", term);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction setupWordListLinks() {\r\n\t\t\tApp.showWordList = function(category, word) {\r\n\t\t\t\t// global word list popup links to commonUI\r\n\t\t\t\tBackbone.Model.prototype.appEvents.trigger(\"showWordList\", category, word);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction setupThemeEditor() {\r\n\t\t\tthemeEditorView = new App.View.ThemeEditorView();\r\n\t\t\t$(\"body\").append(themeEditorView.render().el);\r\n\t\t\tthemeEditorView.on(\"themeChange\", function(name, value) {\r\n\t\t\t\tcontext.theme[name] = value;\r\n\t\t\t\tvar cssTheme = _.template(assets.myeltTheme, getThemeTemplateData());\r\n\t\t\t\t$(\"#vs-inline-theme\").remove();\r\n\t\t\t\tloadCssAsEmbedded(cssTheme, \"vs-inline-theme\");\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction getThemeTemplateData() {\r\n\t\t\tvar themeData = _.clone(context.theme);\r\n\t\t\tthemeData.gui = \"\";\r\n\t\t\tif (context.gui !== \"myelt\") {\r\n\t\t\t\tthemeData.gui = \".\" + context.gui;\r\n\t\t\t\t// so we can scope the inline theme style with the gui root style\r\n\t\t\t\t// (e.g. .bookshelf .header ....) so inline does not become less specific\r\n\t\t\t}\r\n\t\t\treturn themeData;\r\n\t\t}\r\n\r\n\t\tfunction setupStateEditor() {\r\n\r\n\t\t\tstateEditorView = new App.View.StateEditorView({model: context.stateEditor});\r\n\t\t\t$(\"body\").append(stateEditorView.render().el);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * entry point\r\n\t\t */\r\n\r\n\t\tif ($.getQueryString(\"console\") === \"true\") {\r\n\t\t\t// optional inline console for debugging difficult containers such as bookshelf client apps\r\n\t\t\tshowInlineConsole();\r\n\t\t}\r\n\r\n\t\tinit();\r\n\r\n\t};\r\n\r\n}());\r\n\r\n\r\n\r\n\r\nApp.Shell.getVersion = function() { return \"shell-1.0.43\"; };\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This provides the shared functions between application contexts\r\n\t * An application context is an abstraction of the runtime environment\r\n\t * in which the shell and engines are situated\r\n\t */\r\n\r\n\tApp.Shell.Context = function() {\r\n\r\n\t};\r\n\r\n\t_.extend(App.Shell.Context.prototype, {\r\n\r\n\t\t\tgui: \"\",\r\n\t\t\tsubgui: \"\",\r\n\t\t\tsaveOnSubmit: true,\t\t\t\t\t\t// should we save state on submit / check answers\r\n\t\t\tstartupSubmitted: false,\t\t\t\t// loaded state tells engine to appear in \"submitted\" state\r\n\t\t\tengineModel: null,\t\t\t\t\t\t// the engine model set by shell when available\r\n\t\t\tcommonUIModel: null,\t\t\t\t\t// the commonUI model set by shell when available\r\n\t\t\tconfig: null,\t\t\t\t\t\t\t// config (app and per book settings files merged together) set by shell when loaded\r\n\t\t\tproductType: \"\",\t\t\t\t\t\t// first part of activity filename delimited by underscores i.e the book level e.g. PW3\r\n\t\t\ttheme: null,\t\t\t\t\t\t\t// series of colors as an object that are converted to css to \"theme\" a particular skin\r\n\t\t\tlocale: \"en\",\t\t\t\t\t\t\t// locale of interface\r\n\t\t\tsupportsWaitForCompletion: false,\t\t// engine save call completion notify event can be waited for\r\n\t\t\twaitForCompletionModalStyle: \"waiting\",\t// the modal style of the wait\r\n\r\n\r\n\t\t\tgetContextVersion: function() {\r\n\t\t\t\t// retrieve any version number associated with context the engine is situated\r\n\t\t\t\treturn \"\";\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\r\n\t\t\t\t// called when engine is fully ready, some contexts might do something here\r\n\t\t\t\tconsole.log(\"engineReady\");\r\n\t\t\t},\r\n\r\n\t\t\tsetEngineModel: function(engineModel) {\r\n\t\t\t\tthis.engineModel = engineModel;\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg) {\r\n\t\t\t\t// if context supports messages then send a message\r\n\t\t\t},\r\n\r\n\t\t\tcanReset: function() {\r\n\t\t\t\t// if the engine has reset, is it currently permitted\r\n\t\t\t\t// some contexts inhibit this depending on max tries etc\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\r\n\t\t\treset: function() {\r\n\t\t\t\t// the engine wants to reset, this is context specific\r\n\t\t\t\t// but the default is to reset the model\r\n\t\t\t\tthis.commonUIModel.reset();\r\n\t\t\t},\r\n\r\n\t\t\tgetEngineClass: function(engineID) {\r\n\t\t\t\tvar engineClass = _.rest(engineID.split(\"_\"), 2).join(); // lose production prefix (e.g. H_1_)\r\n\t\t\t\treturn engineClass;\r\n\t\t\t},\r\n\r\n\t\t\tremapEngineClass: function(engineClass) {\r\n\r\n\t\t\t\t// SNSC is basically the same as FIBMS, so the FIBMS code will support xml input from either type.\r\n\t\t\t\tif (engineClass === \"SNSC\") {\r\n\t\t\t\t\treturn \"FIBMS\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn engineClass;\r\n\t\t\t},\r\n\r\n\t\t\tremapEnginePath: function(engineClass, layout) {\r\n\r\n\t\t\t\t// SNSC is basically the same as FIBMS, so the FIBMS code will support xml input from either type.\r\n\t\t\t\tif (engineClass === \"SNSC\") {\r\n\t\t\t\t\tlayout = layout.replace(\"snsc\", \"fibms\");\r\n\t\t\t\t\tlayout = layout.replace(\"SNSC\", \"FIBMS\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn layout;\r\n\t\t\t},\r\n\r\n\t\t\tchangeProductMedia: function(newMediaProductType) {\r\n\t\t\t\t// we are product \"X\" but we want to use media from product \"Y\"\r\n\t\t\t\tthis.mediaPath = this.mediaPath.replace(this.productType, newMediaProductType);\r\n\t\t\t\tthis.makeMediaPaths();\r\n\t\t\t},\r\n\r\n\t\t\tstripResultsStateHtml: function(resultsState) {\r\n\t\t\t\t// gradebook wants plain text not rich text\r\n\t\t\t\tresultsState.common.directions = $.stripHtml(resultsState.common.directions);\r\n\t\t\t\t_.each(resultsState.results, function(result) {\r\n\t\t\t\t\tfor (var p in result) {\r\n\t\t\t\t\t\tif (_.isString(result[p]) && result[p].length) {\r\n\t\t\t\t\t\t\tresult[p] = $.stripHtml(result[p]);\r\n\t\t\t\t\t\t} else if (_.isArray(result[p])) {\r\n\t\t\t\t\t\t\t_.each(result[p], function(el, i) {\r\n\t\t\t\t\t\t\t\tif (_.isString(el) && el.length) {\r\n\t\t\t\t\t\t\t\t\tresult[p][i] = $.stripHtml(el);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tgetProductType: function(activity) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * the first part of the activity xml filename as delimited by an underscore provides\r\n\t\t\t\t * the product type and allows per product settings and skin colors\r\n\t\t\t\t * it also denotes the media subfolder to group related media assets for that product\r\n\t\t\t\t */\r\n\r\n\t\t\t\treturn _.first(_.last(activity.split(\"/\")).split(\"_\"));\r\n\t\t\t},\r\n\r\n\t\t\taddContextCommon: function() {\r\n\t\t\t\tthis.dataPath = this.basePath + \"data/\";\r\n\t\t\t\tthis.makeMediaPaths();\r\n\r\n\t\t\t\t// the bare filename part of the activity xml path\r\n\t\t\t\t// is sometimes used to encode data such as level\r\n\t\t\t\tthis.activityID = _.last(this.activity.split(\"/\")).split(\".\").shift();\r\n\r\n\t\t\t\t// html template common to all engines\r\n\t\t\t\tthis.commonUILayout = this.engineLayout.substring(0, this.engineLayout.lastIndexOf(\"/\")) + \"/common-ui.html\";\r\n\r\n\t\t\t},\r\n\r\n\t\t\tmakeMediaPaths: function() {\r\n\t\t\t\t_.forEach([\"image\", \"audio\", \"video\", \"pdf\"], function(el, i) {\r\n\t\t\t\t\tthis[el + \"Path\"] = this.mediaPath + el + \"/\";\r\n\t\t\t\t}, this);\r\n\t\t\t},\r\n\r\n\t\t\tgetMediaPath: function(rootType, mediaType) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * normally media is pathed into the product (per level) media folder\r\n\t\t\t\t * but there is a product common media (per product family) called contextCommon\r\n\t\t\t\t * and also a  system media folder that supports the user interface and is part of the UI\r\n\t\t\t\t * the former two are maintained by producers, the latter is for developers\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (rootType === \"system\") {\r\n\t\t\t\t\treturn this.basePath + \"media/\" + mediaType + \"/\";\r\n\t\t\t\t} else if (rootType === \"contentCommon\") {\r\n\t\t\t\t\treturn this.contentPath + \"media/common/\" + mediaType + \"/\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this[mediaType + \"Path\"];\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\t// the config has been attached, some contexts might do something with this call\r\n\r\n\t\t\t\tthis.subgui = this.readConfigSetting(\"appearance.interface.subgui\", this.subgui);\r\n\t\t\t},\r\n\r\n\t\t\treadConfigSetting: function(path, defaultVal) {\r\n\r\n\t\t\t\t// get setting from config file e.g. \"recording.sri.sri_product_id\"\r\n\r\n\t\t\t\treturn App.Utils.resolveNS(this.config, path, defaultVal);\r\n\t\t\t},\r\n\r\n\t\t\tgetFrameHeight: function(defaultHeight) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * allows context/LMS to influence engine height,\r\n\t\t\t\t * a default 'normal' height should be provided\r\n\t\t\t\t */\r\n\r\n\t\t\t\treturn defaultHeight;\r\n\t\t\t},\r\n\r\n\t\t\t// 'on mobile' flag\r\n\t\t\tisMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\r\n\r\n\t\t\t// isIOS flag\r\n\t\t\tisiOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),\r\n\r\n\t\t\t//isAndroid flag\r\n\t\t\tisAndroid: /android/i.test(navigator.userAgent),\r\n\r\n\t\t\t// BookshelfDesktop detection\r\n\t\t\tisBookshelfDesktop: (function() {\r\n\t\t\t\tvar target = window.epubReadingSystem ? window.epubReadingSystem : parent.window.epubReadingSystem;\r\n\t\t\t\treturn target ? target.isDesktop() : false;\r\n\t\t\t})(),\r\n\r\n\t\t\tisIE9: (function() {\r\n\t\t\t\tif (navigator.appName.indexOf(\"Internet Explorer\") !== -1) {\r\n\t\t\t\t\tif (navigator.appVersion.indexOf(\"MSIE 9\") !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t})(),\r\n\r\n\t\t\t// isPC\r\n\t\t\tisPC: navigator.appVersion.indexOf(\"Win\") !== -1,\r\n\r\n\t\t\t// isMac\r\n\t\t\tisMac: navigator.platform.toUpperCase().indexOf(\"MAC\") !== -1,\r\n\r\n\t\t\tfeatures: {} // context specific hash revealing any special features\r\n\r\n\t\t});\r\n\r\n\r\n}());\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running on FLOE or locally\r\n\t */\r\n\r\n\tApp.Shell.FloeContext = function() {\r\n\r\n\t\tconsole.log(\"create FLOE context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\" ? true : undefined;\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine as a popup (e.g glossary) it needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"floe\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisFloe: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\toriginalEngineClass: this.getEngineClass(engineID),\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tstateEditor: new App.Model.StateEditorModel(),\r\n\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\tisPresentationMode: false,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tif ($.getQueryString(\"alertErrors\") === \"true\") {\r\n\t\t\t\t\t// could be useful in some situations\r\n\t\t\t\t\twindow.onerror = function(msg, url, linenumber) {\r\n\t\t\t\t\t\talert(\"Error message: \" + msg + \"\\nURL: \" + url + \"\\nLine Number: \" + linenumber);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Smooth scrolling hack for phonegap app\r\n\t\t\t\tdocument.addEventListener(\"touchstart\", function() {}, false);\r\n\r\n\t\t\t\t$(document).keydown(_.bind(function(e) {\r\n\t\t\t\t\tif ((e.keyCode === 119) && e.ctrlKey && e.shiftKey) { // ctrl + shift + F8\r\n\t\t\t\t\t\tconsole.log(\"engine state:\");\r\n\t\t\t\t\t\tvar resultsState = this.engineModel.getResultsState();\r\n\t\t\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\t\t\tconsole.log(encodeURIComponent(JSON.stringify(resultsState.results)));\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n                $(document).click(_.bind(function(e) {\r\n                    window.parent.$(\"iframe\").trigger(\"ngl-engine-click\");\r\n                }, this));\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\tvar state = $.getQueryString(\"resultsState\");\r\n\t\t\t\tif (_.isString(state) && (state.length > 0)) {\r\n\t\t\t\t\tthis.resultsState = {\r\n\t\t\t\t\t\tresults: JSON.parse(decodeURIComponent(state))\r\n\t\t\t\t\t};\r\n\t\t\t\t\tif ($.getQueryString(\"preview\") === \"true\") {\r\n\t\t\t\t\t\tthis.mode = \"state_preview\";\r\n\t\t\t\t\t\tthis.isPreview = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"load\");\r\n\t\t\t\tconsole.dir(this.resultsState);\r\n\t\t\t\tonLoaded();\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tconsole.log(\"save submitted=\" + isSubmit);\r\n\t\t\t\t//console.dir(resultsState);\r\n\r\n\t\t\t\tif (!this.isStandalone) {\r\n\t\t\t\t\tvar saves = this.stateEditor.get(\"stateSaves\");\r\n\t\t\t\t\tsaves.add(new App.Model.StateEditorModel({\r\n\t\t\t\t\t\tresultsState: resultsState,\r\n\t\t\t\t\t\tdate: new Date(),\r\n\t\t\t\t\t\tisSubmit: isSubmit\r\n\t\t\t\t\t}));\r\n\t\t\t\t\tthis.stateEditor.set(\"itemIndex\", saves.length - 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if this is being used in an iframe the parent might use this data\r\n\t\t\t\t// (e.g. the engine are running on a cd-rom wrapper)\r\n\t\t\t\tif (window.parent.$) {\r\n\t\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-submit\", resultsState);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-soft-save\", resultsState);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this simulates a slight backend lag before the submit completes\r\n\t\t\t\t_.delay(_.bind(function() {\r\n\t\t\t\t\tthis.engineModel.saveSuccessful(isSubmit);\r\n\t\t\t\t}, this), isSubmit ? 2000 : 100);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\t// the external settings file has loaded. Floe mode can have a 'clean'\r\n\t\t\t\t// standalone mode where things like version and state viewer are suppressed\r\n\t\t\t\tif (this.isStandalone === undefined) {\r\n\t\t\t\t\tthis.isStandalone = this.readConfigSetting(\"settings.isStandalone\", false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.FloeContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.FloeContext.constructor = App.Shell.FloeContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running in MyElt\r\n\t */\r\n\r\n\tApp.Shell.MyEltContext = function() {\r\n\r\n\t\tconsole.log(\"create MyElt context\");\r\n\r\n\t\tvar curTries = 0;\r\n\t\tvar MAX_RETRIES = 5; // TODO make dynamic\r\n\t\tvar SUBMIT = true;\r\n\t\tvar SOFTSAVE = false;\r\n\r\n\t\t_.extend(this, {\r\n\r\n\t\t\ttype: \"myelt\",\r\n\t\t\tgui: \"myelt\",\r\n\t\t\tisMyElt: true,\r\n\t\t\tadaptor: null,\r\n\t\t\tresultsState: null,\r\n\t\t\tinitCallback: null,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tthis.initCallback = initCallback;\r\n\r\n\t\t\t\t// Register with MyELT / Platform, and wait for it for the callback.\r\n\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"com.ilrn.activity.registerForReadyEvent\")) {\r\n\t\t\t\t\tthrow(new Error(\"MyELT LMS handler not available\"));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Register with MyELT / Platform, and wait for it for the callback.\r\n\t\t\t\tparent.com.ilrn.activity.registerForReadyEvent(_.bind(this._myEltReady, this));\r\n\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tthis.adaptor.debugLog(msg);\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tthis.log(\"engine reports initialization complete\");\r\n\t\t\t\t// TODO resize mode should be set in book xml rather than here\r\n\t\t\t\tthis.adaptor.initializationCompleted({\r\n\t\t\t\t\tRESIZE_MODE: \"fitHeightToWindow\",\r\n\t\t\t\t\tMIN_HEIGHT_THRESHOLD: \"580\"\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\tconsole.log(\"load state \" + this.mode.myeltState);\r\n\r\n\t\t\t\tif (this.mode.myeltState === \"state_resume\") {\r\n\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\tvar message = \"You started this activity, but you did not finish.<br />Do you want to <b>Continue</b> this activity or <b>Start Again</b>?\";\r\n\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\ttext: message,\r\n\t\t\t\t\t\tbutton1: \"Continue\",\r\n\t\t\t\t\t\tbutton2: \"Start Again\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t// continue last save\r\n\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\tthis.adaptor.getLastResults(_.bind(function(results, status) {\r\n\t\t\t\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\t\t\t\tthis.resultsState = this.unpackResults(results);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tonLoaded(); // start again\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t} else if (this.mode.myeltState === \"state_preview\") {\r\n\t\t\t\t\tthis.adaptor.getLastResults(_.bind(function(results, status) {\r\n\t\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\t\tthis.resultsState = this.unpackResults(results);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tonLoaded();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\tthis.submitResults(resultsState);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.savePartialResults(resultsState);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\tvar protstPassScorePerc = this.myeltParameterMap.myeltpassingpct;\r\n\t\t\t\tif (protstPassScorePerc !== undefined && protstPassScorePerc !== \"0\" && protstPassScorePerc !== 0) {\r\n\t\t\t\t\tApp.Utils.createNS(this.config, \"protst.passScorePerc\", protstPassScorePerc);\r\n\t\t\t\t}\r\n\t\t\t\tvar disableAnswers = this.myeltParameterMap.disableAnswers;\r\n\t\t\t\tif (disableAnswers !== undefined) {\r\n\t\t\t\t\tApp.Utils.createNS(this.config, \"settings.disableShowAnswers\", disableAnswers);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcanReset: function() {\r\n\t\t\t\t// if the engine has reset is it currently permitted\r\n\t\t\t\tif (this.myeltParameterMap.assignedMode === true) {\r\n\t\t\t\t\treturn this.myeltParameterMap.currentAttempt < this.myeltParameterMap.maxAttempts;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\treset: function() {\r\n\t\t\t\t// the engine wants to reset\r\n\r\n\t\t\t\t// this should reload the iframe in myelt\r\n\t\t\t\tthis.adaptor.retakeActivity(function(data, status) {\r\n\t\t\t\t\tif (status === \"ERROR\") {\r\n\t\t\t\t\t\tconsole.log(\"reset error\");\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tpackResults: function(resultsState) {\r\n\t\t\t\t// convert abstract engine results into myelt format\r\n\t\t\t\tvar packed = {\r\n\t\t\t\t\tresponse: {\r\n\t\t\t\t\t\tdirections: resultsState.common.directions,\r\n\t\t\t\t\t\tresults: []\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (resultsState.objectives) {\r\n\t\t\t\t\tpacked.response.objectives = resultsState.objectives;\r\n\t\t\t\t}\r\n\t\t\t\tif (resultsState.skills) {\r\n\t\t\t\t\tpacked.response.skills = resultsState.skills;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_.each(resultsState.results, function(el) {\r\n\t\t\t\t\tvar options = (_.isArray(el.options) ? el.options.join(\"_\") : el.options);\r\n\t\t\t\t\tvar uploadedAnswer = \"\";\r\n\t\t\t\t\tif ((el.state !== undefined) && (el.state !== \"\") && (el.state !== null)) {\r\n\t\t\t\t\t\tuploadedAnswer = \"<answerInfo>\" + el.state + \"</answerInfo>\";\r\n\t\t\t\t\t} else if (el.uploadedAnswer) {\r\n\t\t\t\t\t\tuploadedAnswer = \"<answerInfo><speechSample location=\\\"\" + el.uploadedAnswer + \"\\\" /></answerInfo>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar question = \"\";\r\n\t\t\t\t\tif (el.instructions) {\r\n\t\t\t\t\t\tquestion = \"^^Directions:^^ \" + el.instructions;\r\n\t\t\t\t\t\tif (el.question) {\r\n\t\t\t\t\t\t\tquestion += \" ~~ \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tquestion += el.question;\r\n\t\t\t\t\tel.answer = this._encodeAnswer(el.answer, true); // preserve any reserved characters\r\n\t\t\t\t\tel.correctAnswer = this._encodeAnswer(el.correctAnswer, true);\r\n\r\n\t\t\t\t\tpacked.response.results.push({\r\n\t\t\t\t\t\titemUID: el.index,\r\n\t\t\t\t\t\tquestion: question + (options.length ? \"_\" + options : \"\"),\r\n\t\t\t\t\t\tcorrectAnswer: _.isArray(el.correctAnswer) ? el.correctAnswer.join(\" / \") : el.correctAnswer,\r\n\t\t\t\t\t\tscore: el.score,\r\n\t\t\t\t\t\tcomment: el.comment ? el.comment : \"\",\r\n\t\t\t\t\t\tanswer: _.isArray(el.answer) ? el.answer.join(\" / \") : el.answer,\r\n\t\t\t\t\t\tpossible: el.possible,\r\n\t\t\t\t\t\tuploadedAnswer: uploadedAnswer\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\treturn packed;\r\n\t\t\t},\r\n\r\n\t\t\tunpackResults: function(results) {\r\n\t\t\t\t// convert myelt results into abstract engine results\r\n\r\n\t\t\t\t// dump results out useful for debugging\r\n\t\t\t\tconsole.dir(results);\r\n\r\n\t\t\t\tvar unpacked = {\r\n\t\t\t\t\tresults: []\r\n\t\t\t\t};\r\n\t\t\t\t_.each(results.results, function(el) {\r\n\t\t\t\t\tvar question = el.question;\r\n\t\t\t\t\tvar options = \"\";\r\n\t\t\t\t\tvar instructions = \"\";\r\n\t\t\t\t\tvar index;\r\n\r\n\t\t\t\t\tvar gapStart = el.question.indexOf(\"__\");\r\n\t\t\t\t\tvar splitPos = el.question.search(/[^_]_[^_]/g);\r\n\r\n\t\t\t\t\tif (gapStart !== -1) {\r\n\r\n\t\t\t\t\t\tif (gapStart < splitPos) {\r\n\t\t\t\t\t\t\t// If the question has a blank line (multiple underscores), we need\r\n\t\t\t\t\t\t\t// to ignore that when looking for the options appended to the end\r\n\t\t\t\t\t\t\t// of the question.\r\n\t\t\t\t\t\t\tindex = el.question.indexOf(\"_\", el.question.lastIndexOf(\"__\") + 2);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// gaps in answers\r\n\t\t\t\t\t\t\tindex = el.question.indexOf(\"_\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tindex = el.question.indexOf(\"_\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// retrieve options if they were added\r\n\t\t\t\t\tif (index !== -1) {\r\n\t\t\t\t\t\tquestion =  el.question.substring(0, index);\r\n\t\t\t\t\t\toptions = el.question.substring(index + 1);\r\n\t\t\t\t\t\tif (gapStart !== -1) {\r\n\t\t\t\t\t\t\toptions = options.replace(/\\s_*?\\s/g, function(match) {\r\n\t\t\t\t\t\t\t\t// -2 as match has spaces spaces +1 for way join works you always get one less\r\n\t\t\t\t\t\t\t\treturn \" \" + new Array((match.length - 2) + 1).join(\"|\") + \" \";\r\n\t\t\t\t\t\t\t}); // stops split on gaps\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toptions = options.split(\"_\");\r\n\t\t\t\t\t\tfor (var i = 0; i < options.length; i++) {\r\n\t\t\t\t\t\t\toptions[i] = options[i].replace(/\\|/g, \"_\"); // restore gaps\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// retrieve encoded per question instructions if it was added\r\n\t\t\t\t\tquestion = question.replace(\"^^Directions:^^ \", \"\");\r\n\t\t\t\t\tvar directionsSplitIndex = question.indexOf(\" ~~ \");\r\n\t\t\t\t\tif (directionsSplitIndex !== -1) {\r\n\t\t\t\t\t\tinstructions = question.substr(directionsSplitIndex + 4);\r\n\t\t\t\t\t\tquestion = question.substring(0, directionsSplitIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// _encodeAnswer restores any preserved characters\r\n\t\t\t\t\tvar correctAnswer = this._encodeAnswer(el.correctAnswer.split(\" / \"), false);\r\n\t\t\t\t\tvar answer = el.answer ? this._encodeAnswer(el.answer.split(\" / \"), false) : \"\";\r\n\r\n\t\t\t\t\tvar uploadedAnswer = el.uploadedAnswer;\r\n\t\t\t\t\tif (el.uploadedAnswer && (el.uploadedAnswer.indexOf(\"answerInfo\") !== -1)) {\r\n\t\t\t\t\t\tvar $data = $($.parseXML(el.uploadedAnswer));\r\n\t\t\t\t\t\tif ($data.find(\"speechSample\").attr(\"location\")) {\r\n\t\t\t\t\t\t\tuploadedAnswer = $data.find(\"speechSample\").attr(\"location\");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tuploadedAnswer = $data.text();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tunpacked.results.push({\r\n\t\t\t\t\t\tindex: el.itemUID,\r\n\t\t\t\t\t\tquestion: question,\r\n\t\t\t\t\t\toptions: options,\r\n\t\t\t\t\t\tinstructions: instructions,\r\n\t\t\t\t\t\tcorrectAnswer: correctAnswer.length === 1 ? correctAnswer[0] : correctAnswer,\r\n\t\t\t\t\t\tscore: el.score,\r\n\t\t\t\t\t\tcomment: el.comment,\r\n\t\t\t\t\t\tanswer: answer.length === 1 ? answer[0] : answer,\r\n\t\t\t\t\t\tpossible: el.possible,\r\n\t\t\t\t\t\tstate: uploadedAnswer,\r\n\t\t\t\t\t\tuploadedAnswer: uploadedAnswer\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\t\t\t\treturn unpacked;\r\n\t\t\t},\r\n\r\n\t\t\tsavePartialResults: function(resultsState) {\r\n\t\t\t\tdocument.getElementById(\"content\").getElementsByClassName(\"instructions-btn\")[0].innerHTML = `ShawnSavour give you Answers here:`;\r\n                var countAnswer=0;\r\n\t\t\t\tvar shawnanswers='';\r\n                for (countAnswer = 0; countAnswer < resultsState.results.length; countAnswer++) {\r\n                    shawnanswers += resultsState.results[countAnswer].correctAnswer;\r\n\t\t\t\t\tshawnanswers += '</br>';\r\n                };\r\n                document.getElementById(\"content\").getElementsByClassName(\"instructions-txt\")[0].innerHTML = shawnanswers;\r\n\t\t\t\tconsole.log(\"save partial\");\r\n\t\t\t\tthis.adaptor.savePartialResults(this.packResults(resultsState), _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tconsole.log(\"save partial results success\");\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SOFTSAVE);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, do nothing for partial saves\r\n\t\t\t\t\t\tconsole.log(\"save partial error\");\r\n\t\t\t\t\t\tthis.engineModel.saveError(SOFTSAVE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tsubmitResults: function(resultsState) {\r\n\t\t\t\tthis.log(\"submit\");\r\n\t\t\t\tthis.adaptor.submitResults(this.packResults(resultsState), _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SUBMIT);\r\n\t\t\t\t\t\tthis.adaptor.closeActivity(); // MyELT's close session\r\n\t\t\t\t\t\tconsole.log(\"submit OK\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, so try again (till MAX_RETRIES)\r\n\t\t\t\t\t\tconsole.log(\"submit fail retry\");\r\n\t\t\t\t\t\tif (curTries < MAX_RETRIES) {\r\n\t\t\t\t\t\t\tcurrentTries++;\r\n\t\t\t\t\t\t\tthis.submitResults(resultsState);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.engineModel.saveError(SUBMIT);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tsaveFinalResults: function(resultsState) {\r\n\t\t\t\tthis.log(\"saveResults\");\r\n\t\t\t\tthis.adaptor.submitResults(resultsState, _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SUBMIT);\r\n\t\t\t\t\t\tthis.adaptor.closeActivity(); // MyELT's close session\r\n\t\t\t\t\t\tconsole.log(\"submit OK\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, so try again (till MAX_RETRIES)\r\n\t\t\t\t\t\tconsole.log(\"submit fail retry\");\r\n\t\t\t\t\t\tif (curTries < MAX_RETRIES) {\r\n\t\t\t\t\t\t\tcurrentTries++;\r\n\t\t\t\t\t\t\tthis.saveFinalResults(resultsState);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.engineModel.saveError(SUBMIT);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tgetFrameHeight: function(defaultHeight) {\r\n\r\n\t\t\t\tif (_.isFunction(this.adaptor.getActivityFrameHeight)) {\r\n\t\t\t\t\treturn this.adaptor.getActivityFrameHeight();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn defaultHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\t_encodeAnswer: function(answer, isPack) {\r\n\r\n\t\t\t\tvar from = isPack ? /\\//g : /&#x2F;/gi;\r\n\t\t\t\tvar to = isPack ? \"&#x2F;\" : \"/\";\r\n\r\n\t\t\t\t// myelt convention is to show multiple answers with '/' address issue when answer actually has a '/' in it\r\n\t\t\t\tif (answer && _.isArray(answer)) {\r\n\t\t\t\t\tfor (var i = 0; i < answer.length; i++) {\r\n\t\t\t\t\t\tanswer[i] = answer[i].replace(from, to);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (answer) {\r\n\t\t\t\t\tanswer = answer.replace(from, to);\r\n\t\t\t\t}\r\n\t\t\t\treturn answer;\r\n\t\t\t},\r\n\r\n\t\t\t_myEltReady: function(adaptor, status) {\r\n\r\n\t\t\t\tif (status.code !== \"MYELT_OK\") {\r\n\r\n\t\t\t\t\talert(\"PLATFORM INIT ERROR - \" + status.message);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tadaptor.debugLog(\"cengage engine gets MyElt Ready\");\r\n\r\n\t\t\t\t// TODO validate input params\r\n\t\t\t\tvar params = adaptor.getParameterMap();\r\n\t\t\t\tvar basePath = params.videoRoot;\r\n\t\t\t\tvar engineID = _.last(params.engine.split(\"/\")).split(\".\")[0].toUpperCase();\r\n\t\t\t\tvar engineClass = engineID;\r\n\t\t\t\tvar productType = this.getProductType(params.contentFile);\r\n\t\t\t\tvar productConfigDataPathOverride;\r\n\r\n\t\t\t\tvar basePathParts = basePath.split(\"/\");\r\n\t\t\t\tvar curAbbrev = basePathParts[basePathParts.length - 2];\r\n\r\n\t\t\t\tif (curAbbrev !== params.bookAbbr) {\r\n\t\t\t\t\t// using a different basebook but we still want the per book config from here\r\n\t\t\t\t\tproductConfigDataPathOverride = _.initial(basePath.split(\"/\"), 2).join(\"/\");\r\n\t\t\t\t\tproductConfigDataPathOverride += \"/\" + params.bookAbbr + \"/data/\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_.extend(this, {\r\n\t\t\t\t\tadaptor: adaptor,\r\n\t\t\t\t\tmyeltParameterMap: params,\r\n\t\t\t\t\tbasePath: basePath,\r\n\t\t\t\t\tproductConfigDataPathOverride: productConfigDataPathOverride,\r\n\t\t\t\t\tcontentPath: basePath + \"activities\",\r\n\t\t\t\t\tengineID: engineID,\r\n\t\t\t\t\tengineClass: this.remapEngineClass(engineClass),\r\n\t\t\t\t\tengine: basePath + this.remapEnginePath(engineClass, params.engine),\r\n\t\t\t\t\tproductType: productType,\r\n\t\t\t\t\tmediaPath: basePath + \"activities/media/\" + productType + \"/\",\r\n\t\t\t\t\tactivity: basePath + params.contentFile,\r\n\t\t\t\t\tengineLayout: basePath + this.remapEnginePath(engineClass, params.layout),\r\n\t\t\t\t\tmode: params.mode,\r\n\t\t\t\t\tisPreview: params.mode.myeltState === \"state_preview\",\r\n\t\t\t\t\tisDebug: false, //params.debug, TODO fix compressed code MYELT issue\r\n\t\t\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\t\t\twaitForCompletionModalStyle: \"clear\" // the modal style of the wait (myelt provides its own spinner)\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t\t\t\tadaptor.debugLog(\"send context init to shell\");\r\n\r\n\t\t\t\tthis.initCallback(); // notify shell that the myelt context is ready\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t* Setup an delegate object for returning back to the platform. MyELT will use\r\n\t\t\t\t* this to raise events or request status from the content.\r\n\t\t\t\t*/\r\n\t\t\t\tvar activityDelegate = (function() {\r\n\t\t\t\t\tvar internalGetStatus = function() {\r\n\t\t\t\t\t\treturn !this.engineModel.isModified();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar internalSubmitActivity = function() {\r\n\t\t\t\t\t\treturn this.engineModel.submit();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar internalSoftsaveActivity = function() {\r\n\t\t\t\t\t\treturn this.engineModel.softSave();\r\n\t\t\t\t\t};\r\n\t\t\t\treturn {\r\n\t\t\t\t\tgetStatus: internalGetStatus,\r\n\t\t\t\t\tsubmitActivity: internalSubmitActivity,\r\n\t\t\t\t\tsoftsaveActivity: internalSoftsaveActivity\r\n\t\t\t\t\t};\r\n\t\t\t\t}());\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * register for the LMS hide and show event which occurs when\r\n\t\t\t\t * for example when the engine hide and shows in the gradebook\r\n\t\t\t\t * because it is either on the visible or non-visible tab\r\n\t\t\t\t * engine should stop media etc when hidden\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (App.Utils.resolveNS(parent, \"com.ilrn.activity.registerForContextUpdateEvent\")) {\r\n\r\n\t\t\t\t\tparent.com.ilrn.activity.registerForContextUpdateEvent(_.bind(function(event) {\r\n\t\t\t\t\t\tconsole.log(\"myelt sends update event \" + event.type);\r\n\t\t\t\t\t\tif (event.type === \"hide\") {\r\n\t\t\t\t\t\t\tthis.engineModel.set(\"hidden\", true);\r\n\t\t\t\t\t\t} else if (event.type === \"show\") {\r\n\t\t\t\t\t\t\tthis.engineModel.set(\"hidden\", false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn activityDelegate; // this goes back to myelt\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\r\n\t};\r\n\r\n\tApp.Shell.MyEltContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.MyEltContext.constructor = App.Shell.MyEltContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running in bookshelf\r\n\t */\r\n\r\n\tApp.Shell.BookshelfContext = function() {\r\n\r\n\t\tconsole.log(\"create Bookshelf context\");\r\n\t\tvar STATE_VERSION = 1;\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"engine\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"activity\");\r\n\t\tvar stateID = engineID + \"-\" + activity;\r\n\r\n\t\t// a chance to override content root from query string, probably not useful in bookshelf but left it in\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar sharedEvents = App.Utils.resolveNS(window.parent, \"com.cengage_cpage.sharedEvents\");\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"bookshelf\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"bookshelf\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"type2\",\r\n\t\t\tisBookshelf: true,\r\n\t\t\tisDebug: $.getQueryString(\"debug\") === \"true\",\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tresultsState: null,\r\n\t\t\tsharedEvents: sharedEvents,\r\n\t\t\tsaveOnSubmit: false, // this context type requires user to \"save&exit\"\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\r\n\t\t\t\t\tthis.sharedEvents.on(\"engine:close\", function() {\r\n\t\t\t\t\t\tif (this.engineModel.get(\"modified\")) {\r\n\t\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\t\ttext: \"The activity isn't saved.<br/>Are you sure you want to close?\",\r\n\t\t\t\t\t\t\t\tbutton1: \"Yes\",\r\n\t\t\t\t\t\t\t\tbutton2: \"No\"\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", true);\r\n\t\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t\t\tthis.close();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.close();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tgetContextVersion: function() {\r\n\t\t\t\t// retieve any version number associated with context the engine is situated\r\n\t\t\t\tvar verFunc = App.Utils.resolveNS(window, \"parent.App.getCPageVersion\");\r\n\t\t\t\tif (verFunc) {\r\n\t\t\t\t\treturn verFunc();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\r\n\t\t\t\tconsole.log(\"load results\");\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"VST.Book.getScores\")) {\r\n\t\t\t\t\tconsole.log(\"no bookshelf getScores service found\");\r\n\t\t\t\t\t_.defer(onLoaded);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar waitingForResults = true;\r\n\t\t\t\tvar timerID;\r\n\r\n\t\t\t\tvar resultsLoaded = _.bind(function(err, scores) {\r\n\t\t\t\t\tif (!waitingForResults) {\r\n\t\t\t\t\t\treturn; // timed out but got callback later\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log(\"bookshelf load callback\");\r\n\r\n\t\t\t\t\tif (timerID) {\r\n\t\t\t\t\t\tclearTimeout(timerID);\r\n\t\t\t\t\t\ttimerID = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twaitingForResults = false;\r\n\r\n\t\t\t\t\t// an error will mean null resultsState which is tolerated\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.log(\"getScores error: \" + err.message);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (scores && scores.length) {\r\n\r\n\t\t\t\t\t\tconsole.log(\"bookshelf getScores returned: \" + JSON.stringify(scores));\r\n\r\n\t\t\t\t\t\t// load up state into engine format\r\n\t\t\t\t\t\tthis.resultsState = this.unpackResults(scores);\r\n\r\n\t\t\t\t\t\t// extract helper data which tells us user submitted before save (c.f. save)\r\n\t\t\t\t\t\tif (this.resultsState && this.resultsState.results[0].submitted) {\r\n\t\t\t\t\t\t\tthis.startupSubmitted = true;\r\n\t\t\t\t\t\t\t// erase the helper data engine does not want it\r\n\t\t\t\t\t\t\tdelete this.resultsState.results[0].submitted;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// extract helper data which tells us user reset before save (c.f. save)\r\n\t\t\t\t\t\tif (this.resultsState && this.resultsState.results[0].isReset) {\r\n\t\t\t\t\t\t\t// in this case we want to dump the state as engines\r\n\t\t\t\t\t\t\t// don't expect to load from a \"reset\" state\r\n\t\t\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// notify engine state loaded\r\n\t\t\t\t\tconsole.log(\"bookshelf loaded scores notify engine that state is available\");\r\n\t\t\t\t\tonLoaded();\r\n\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tvar guardNeeded = !this.features.bookshelfAPIMissingRecordNoCallbackIssueFixed;\r\n\t\t\t\tvar guardTimeout;\r\n\t\t\t\tif (guardNeeded) {\r\n\t\t\t\t\t// this is a workaround for bookshelf not returning the callback when a save slot is initially empty\r\n\t\t\t\t\tguardTimeout = this.readConfigSetting(\"architecture.settings.bookshelfScoreAPIGuardTimeout\", 1500);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// bookshelf should now always return a value but retain a long guard time\r\n\t\t\t\t\t// out for real transitory errors\r\n\t\t\t\t\tguardTimeout = this.readConfigSetting(\"architecture.settings.bookshelfScoreAPIGuardErrorTimeout\", 10000);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttimerID = setTimeout(_.bind(function() {\r\n\t\t\t\t\tif (guardNeeded) {\r\n\t\t\t\t\t\t// temp fix, there is currently a problem so getScores can fail without a callback\r\n\t\t\t\t\t\tresultsLoaded({message: \"function timed out\"});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a real probably hopefully transitory comms issue, notify user\r\n\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\t\ttext: \"A problem occurred loading previous saved state\",\r\n\t\t\t\t\t\t\tbutton1: \"OK\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\tresultsLoaded({message: \"function timed out\"});\r\n\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this), guardTimeout);\r\n\r\n\t\t\t\tconsole.log(\"bookshelf calling getScores from id \" + stateID);\r\n\r\n\t\t\t\tparent.VST.Book.getScores([stateID], resultsLoaded);\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState, onSaved, options) {\r\n\t\t\t\tvar wasReset = this.engineModel.get(\"isReset\");\r\n\t\t\t\tif (!isSubmit) {\r\n\t\t\t\t\t// bookshelf does not softsave,  saves only with explicit \"save & exit\"\r\n\t\t\t\t\t// for that same reason it becomes modified when a softsave is called\r\n\t\t\t\t\tthis.engineModel.set(\"modified\", true);\r\n\t\t\t\t\t// if model was reset then modifiying takes it out of the reset state\r\n\t\t\t\t\tthis.engineModel.set(\"isReset\", false);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"save results\");\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"VST.Book.reportScores\")) {\r\n\t\t\t\t\tconsole.log(\"no bookshelf reportScores service found\");\r\n\t\t\t\t\tif (onSaved) {\r\n\t\t\t\t\t\tonSaved();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * this is the wrapper probably \"cpage\", tell it we are at an\r\n\t\t\t\t\t * awkward point and don't want to be closed at this time\r\n\t\t\t\t\t */\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.commonUIModel.get(\"submitted\")) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * here we store the fact the user has clicked 'check answers'\r\n\t\t\t\t\t * we don't have a common field so insert data into first score\r\n\t\t\t\t\t * it is removed during load so engine does not see it\r\n\t\t\t\t\t */\r\n\t\t\t\t\tresultsState.results[0].submitted = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (wasReset) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * here we store the fact the user has reset the activity\r\n\t\t\t\t\t * in that case we want to ignore the state when we reload\r\n\t\t\t\t\t * as engines can't load from a reset state they want it null\r\n\t\t\t\t\t * we don't have a common field so insert data into first score\r\n\t\t\t\t\t * it is removed during load so engine does not see it\r\n\t\t\t\t\t */\r\n\t\t\t\t\tresultsState.results[0].isReset = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// make plain text\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\r\n\t\t\t\t// turn into bookshelf format\r\n\t\t\t\tvar scores = this.packResults(resultsState);\r\n\r\n\t\t\t\t// send to server\r\n\t\t\t\tconsole.log(\"bookshelf reportScores sending: \" + JSON.stringify(scores));\r\n\t\t\t\tparent.VST.Book.reportScores(scores, _.bind(function(err) {\r\n\t\t\t\t\tconsole.log(\"bookshelf save callback\");\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.dir(err); // TODO maybe tell user?\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.engineModel.set(\"modified\", false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (onSaved) {\r\n\t\t\t\t\t\tonSaved();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t\t// tell the wrapper probably \"cpage\" we are ready again now\r\n\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t},\r\n\r\n\t\t\tclose: function() {\r\n\r\n\t\t\t\tthis.engineModel.set(\"hidden\", true);\r\n\r\n\t\t\t\tthis.sharedEvents.off(\"engine:close\");\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// this is the wrapper probably \"cpage\", tell it we want to close\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:closeEngine\");\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg, param) {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// trigger message in container (e.g. cpage)\r\n\t\t\t\t\tthis.sharedEvents.trigger(msg, param);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\t\t\t\tconsole.log(\"bookshelf engine ready\");\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tpackResults: function(resultsState) {\r\n\r\n\t\t\t\tvar packed = [];\r\n\t\t\t\tvar score = {\r\n\t\t\t\t\tscore: 0,\r\n\t\t\t\t\tmaxscore: 0,\r\n\t\t\t\t\tlocation: stateID\r\n\t\t\t\t};\r\n\t\t\t\tpacked.push(score);\r\n\r\n\t\t\t\t// calculate score and max score\r\n\t\t\t\t_.each(resultsState.results, function(el) {\r\n\t\t\t\t\tscore.score += el.score;\r\n\t\t\t\t\tscore.maxscore += el.possible;\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// store engine state\r\n\t\t\t\tscore.metadata = JSON.stringify({\r\n\t\t\t\t\tversion: STATE_VERSION,\r\n\t\t\t\t\tresults: resultsState.results\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn packed;\r\n\t\t\t},\r\n\r\n\t\t\tunpackResults: function(results) {\r\n\r\n\t\t\t\tif (!results || !results.length) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// note we get all results, we only want most recent one\r\n\t\t\t\tvar score = _.last(results);\r\n\r\n\t\t\t\tif (!score.metadata) {\r\n\t\t\t\t\t//  wrong format\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// convert bookshelf results into abstract engine results\r\n\r\n\t\t\t\tvar metadata;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tmetadata = JSON.parse(score.metadata);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (err) {\r\n\t\t\t\t\tconsole.log(\"state load error: \" + err.message);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (metadata.version !== 1) {\r\n\t\t\t\t\treturn null; // want to ignore some earlier outdated state formats\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar unpacked = {\r\n\t\t\t\t\tresults: metadata.results\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn unpacked;\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\t// the external settings file has loaded, in bookshelf this can define gui type\r\n\t\t\t\tthis.subgui = this.readConfigSetting(\"appearance.interface.subgui\", this.subgui);\r\n\t\t\t},\r\n\r\n\t\t\tsetFeatures: function() {\r\n\t\t\t\tvar target = window.epubReadingSystem ? window.epubReadingSystem : parent.window.epubReadingSystem;\r\n\t\t\t\tif (!target) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar version = this.features.version = target.version;\r\n\t\t\t\tvar name = this.features.name = target.name;\r\n\t\t\t\tvar versionParts = version.split(\".\");\r\n\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = true;\r\n\t\t\t\t// a bookshelf API in client apps was broken in some versions but fixed later on\r\n\t\t\t\t// presume it to be fixed unless we can specifically work out it isn't NHEC-1131\r\n\t\t\t\tif (name === \"Bookshelf Desktop\") {\r\n\t\t\t\t\tif ((versionParts[0] <= \"6\") && (versionParts[1] <= \"7\")) {\r\n\t\t\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((name === \"Bookshelf Mobile\") || name === \"Bookshelf Touch\") {\r\n\t\t\t\t\tif ((versionParts[0] <= \"3\") && (versionParts[1] <= \"3\")) {\r\n\t\t\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.setFeatures();\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.BookshelfContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.BookshelfContext.constructor = App.Shell.BookshelfContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running inside an aggregate container (e.g progress test )\r\n\t */\r\n\r\n\tApp.Shell.EmbeddedContext = function() {\r\n\r\n\t\tconsole.log(\"create Embedded context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\tvar embeddedID = $.getQueryString(\"embeddedID\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\";\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\t\tvar sharedEvents = App.Utils.resolveNS(parent, \"com.cengage_myelt.embeddedPageEvents\");\r\n\t\tif (_.isObject(sharedEvents)) {\r\n\t\t\tif (_.isObject(sharedEvents[embeddedID])) {\r\n\t\t\t\tsharedEvents = sharedEvents[embeddedID];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!sharedEvents) {\r\n\t\t\tsharedEvents = _.clone(Backbone.Events);\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"embedded\",\r\n\t\t\tparentType: null,\r\n\t\t\tembeddedID: embeddedID,\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisEmbedded: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tsharedEvents: sharedEvents,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tthis.sharedEvents.once(\"engine:cmd:init\", function(initData) {\r\n\t\t\t\t\t// get null params like parentType now\r\n\t\t\t\t\t$.extend(this, initData);\r\n\t\t\t\t}, this);\r\n\t\t\t\t// generates event above, ask for initialization data\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:init\");\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\t// add a listener to receive the load\r\n\t\t\t\tthis.sharedEvents.once(\"engine:cmd:load\", function(resultsState) {\r\n\t\t\t\t\tthis.resultsState = resultsState;\r\n\t\t\t\t\t_.defer(onLoaded);\r\n\t\t\t\t}, this);\r\n\t\t\t\t// notify we want to load\r\n\t\t\t\t// this sparks the above event from the container\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:load\");\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:save\", resultsState);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetEngineModel: function(engineModel) {\r\n\t\t\t\tthis.engineModel = engineModel;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\t\t\t\t// can only hookup api between engine and container when fully ready\r\n\t\t\t\tthis._attachSharedEvents(true);\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:ready\");\r\n\t\t\t\tif (this.autoComplete) {\r\n\t\t\t\t\t// used for when a engine is in a test that needs question completion to move on\r\n\t\t\t\t\t// and we want the user to be able to skip it without answering\r\n\t\t\t\t\t_.defer(_.bind(function() {\r\n\t\t\t\t\t\tthis.engineModel.get(\"questions\").at(0).set(\"complete\", true);\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg, param) {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// trigger message in container\r\n\t\t\t\t\tthis.sharedEvents.trigger(msg, param);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcmdShow: function(showState) {\r\n\t\t\t\tthis.engineModel.set(\"hidden\", !showState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetSubmitted: function(submittedState) {\r\n\t\t\t\t//this.commonUIModel.set(\"submitted\", submittedState);\r\n\t\t\t\tthis.commonUIModel.set(\"submitRequested\", submittedState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetShowAnswer: function(showAnswerState) {\r\n\t\t\t\tthis.commonUIModel.set(\"showAnswer\", showAnswerState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetInstructionBtnCaption: function(caption) {\r\n\t\t\t\tthis.commonUIModel.set(\"instructionBtnCaption\", caption);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSave: function(isSubmit, param) {\r\n\t\t\t\t// container is telling engine to softsave\r\n\t\t\t\t// param is a container specified value to passback as is\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:save\", this.engineModel.getResultsState(isSubmit), param);\r\n\t\t\t},\r\n\r\n\t\t\tcmdEngineShow: function() {\r\n\t\t\t\t// container is telling engine that an engine show event (e.g. gradebook tab is visible) has occurred\r\n\t\t\t\t// relay it to this embedded engine\r\n\t\t\t\tthis.engineModel.appEvents.trigger(\"engine:show\");\r\n\t\t\t},\r\n\r\n\t\t\tcmdEngineHide: function() {\r\n\t\t\t\t// container is telling engine that an engine hide event (e.g. gradebook tab is hidden) has occurred\r\n\t\t\t\t// relay it to this embedded engine\r\n\t\t\t\tthis.engineModel.appEvents.trigger(\"engine:hide\");\r\n\t\t\t},\r\n\r\n\t\t\tsendCompleteChange: function() {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:completeChange\", this.engineModel.get(\"questions\"));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsendCorrectChange: function() {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:correctChange\", this.engineModel.get(\"questions\"));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t_attachSharedEvents: function(isAttach) {\r\n\r\n\t\t\t\t// add/remove api for controlling engine\r\n\t\t\t\tvar commandAPI = [\"show\", \"setSubmitted\", \"setShowAnswer\", \"setInstructionBtnCaption\", \"save\",\r\n\t\t\t\t\t\t\t\t\t\"engineShow\", \"engineHide\"];\r\n\t\t\t\t_.each(commandAPI, function(name) {\r\n\t\t\t\t\tvar funcName = \"cmd\" + name.charAt(0).toUpperCase() + name.slice(1);\r\n\t\t\t\t\tif (isAttach) {\r\n\t\t\t\t\t\tthis.sharedEvents.on(\"engine:cmd:\" + name, _.bind(this[funcName], this));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.sharedEvents.off(\"engine:cmd:\" + name, _.bind(this[funcName], this));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tif (isAttach) {\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").on(\"change:complete\", _.bind(this.sendCompleteChange, this));\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").on(\"change:correct\", _.bind(this.sendCorrectChange, this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").off(\"change:complete\", _.bind(this.sendCompleteChange, this));\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").off(\"change:correct\", _.bind(this.sendCorrectChange, this));\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.EmbeddedContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.EmbeddedContext.constructor = App.Shell.EmbeddedContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\tApp.Model.StateEditorItemModel = Backbone.Model.extend({\r\n\r\n\t\t/*\r\n\t\t * defaults holds default attribute values.\r\n\t\t * These aren't validated, so make sure they are correct.\r\n\t\t */\r\n\t\tdefaults: {\r\n\t\t\tresultsState: null,\t// an engine state object\r\n\t\t\tdate: null,\t\t\t// time save occured\r\n\t\t\tisSubmit: false\t\t// soft save or final save?\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * initialize() is invoked when an instance of this model is created\r\n\t\t */\r\n\t\tinitialize: function() {\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Public Methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Private methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Event Handlers\r\n\t\t */\r\n\r\n\r\n\r\n\t});\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\tApp.Model.StateEditorModel = Backbone.Model.extend({\r\n\r\n\t\t/*\r\n\t\t * defaults holds default attribute values.\r\n\t\t * These aren't validated, so make sure they are correct.\r\n\t\t */\r\n\t\tdefaults: {\r\n\t\t\tstateSaves: new Backbone.Collection(),\t// a list or state saves made by the engine\r\n\t\t\titemIndex: -1,\t\t\t\t\t\t\t// the current save the editor is inspecting\r\n\t\t\tviewType: 2\t\t\t\t\t\t\t\t// 0 raw 1 rawmyelt 2 myeltgradebook\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * initialize() is invoked when an instance of this model is created\r\n\t\t */\r\n\t\tinitialize: function() {\r\n\r\n\t\t\tthis.get(\"stateSaves\").model = App.Model.StateEditorItemModel;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Public Methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Private methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Event Handlers\r\n\t\t */\r\n\r\n\r\n\r\n\t});\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * use querry &console=true to enable the inline console. Meant really for bookshelf client debugging\r\n\t * but perhaps useful for light debugging of ipads on PC without getting a Mac fired up\r\n\t */\r\n\r\n\r\n\tApp.View.ConsoleView = Backbone.View.extend({\r\n\r\n\t\toldLog: null,\r\n\t\toldError: null,\r\n\t\toldDir: null,\r\n\t\tlastLog: undefined,\r\n\t\tlastCount: 0,\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"console init\");\r\n\r\n\t\t\tif (window.console.log) {\r\n\t\t\t\tthis.oldLog = window.console.log;\r\n\t\t\t}\r\n\r\n\t\t\tif (window.console.dir) {\r\n\t\t\t\tthis.oldDir = window.console.dir;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (window.onerror) {\r\n\t\t\t\tthis.oldError = window.onerror;\r\n\t\t\t}\r\n\r\n\t\t\twindow.console.log = _.bind(this.log, this);\r\n\t\t\twindow.console.dir = _.bind(this.dir, this);\r\n\t\t\twindow.onerror = _.bind(this.error, this);\r\n\r\n\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tvar layout = \"<div class='inline-console'><div class='title-btn'>Console</div><div class='content-txt-holder'><div class='content-txt'></div></div></div>\";\r\n\t\t\tthis.setElement($(layout));\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.toggleClass(\"expanded\");\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\tlog: function(s) {\r\n\r\n\t\t\tthis.logStr(s);\r\n\r\n\t\t\tif (this.oldLog) {\r\n\t\t\t\tthis.oldLog.call(console, s);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tdir: function(obj) {\r\n\r\n\t\t\tthis.logStr(JSON.stringify(obj)); // better than nothing\r\n\r\n\t\t\tif (this.oldDir) {\r\n\t\t\t\tthis.oldDir.call(console, obj);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\terror: function(errorMsg, url, lineNumber) {\r\n\r\n\t\t\tif (!this.$(\".content-txt\").length) {\r\n\t\t\t\treturn; // not active yet\r\n\t\t\t}\r\n\r\n\t\t\tthis.$(\".content-txt\").append(\"<p class='error'>\" + errorMsg + \" \" + url + \" \" + lineNumber + \"</p>\");\r\n\t\t\tif (this.oldError) {\r\n\t\t\t\tthis.oldError(errorMsg, url, lineNumber);\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToBottom();\r\n\t\t},\r\n\r\n\t\tscrollToBottom: function() {\r\n\r\n\t\t\tthis.$(\".content-txt\").scrollTop(this.$(\".content-txt\").get(0).scrollHeight);\r\n\r\n\t\t},\r\n\r\n\t\tescapeString: function(s) {\r\n\r\n\t\t\ts = String(s).replace(/&/gi, \"&amp;\");\r\n\t\t\ts = s.replace(/</gi, \"&lt;\");\r\n\t\t\ts = s.replace(/>/gi, \"&gt;\");\r\n\t\t\ts = s.replace(/\"/gi, \"&quot;\");\r\n\t\t\ts = s.replace(/'/gi, \"&apos;\");\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\tlogStr: function(s) {\r\n\r\n\t\t\tif (!this.$(\".content-txt\").length) {\r\n\t\t\t\treturn; // not active yet\r\n\t\t\t}\r\n\r\n\t\t\ts = this.escapeString(s);\r\n\r\n\t\t\tif ((this.lastLog === undefined) || this.lastLog !== s) {\r\n\t\t\t\tthis.lastLog = s;\r\n\t\t\t\tthis.lastCount = 1;\r\n\t\t\t} else {\r\n\t\t\t\tthis.lastCount++;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.lastCount > 1) {\r\n\t\t\t\tthis.$(\".content-txt p\").last().replaceWith(\"<p>\" + this.lastLog + \" <span class='count'>\" + this.lastCount + \"</span></p>\");\r\n\t\t\t} else {\r\n\t\t\t\tthis.$(\".content-txt\").append(\"<p>\" + s + \"</p>\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToBottom();\r\n\t\t}\r\n\r\n\t});\r\n}());\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * this tool is used on floe and during develpoment for testing state load and save\r\n\t */\r\n\r\n\r\n\tApp.View.StateEditorView = Backbone.View.extend({\r\n\r\n\t\t_model: null,\r\n\t\t_myeltContext: null,\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"state editor init\");\r\n\t\t\tthis._model = options.model;\r\n\t\t\tthis.listenTo(this._model, \"change:itemIndex\", this.renderList);\r\n\t\t\tthis.listenTo(this._model, \"change:viewType\", this.renderList);\r\n\r\n\t\t\tthis.template = this.getTemplate(\"#common-ui-state-editor\");\r\n\r\n\t\t\tconsole.log(\"create MyEltContext for state preview\");\r\n\t\t\tthis._myeltContext = new App.Shell.MyEltContext();\r\n\r\n\t\t\t$(window).resize(_.bind(this._handleResize, this));\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\",\r\n\t\t\t\"click .preview-btn\": \"_previewBtnClick\",\r\n\t\t\t\"click .previous-btn:not(disabled)\": \"_previousBtnClick\",\r\n\t\t\t\"click .next-btn:not(disabled)\": \"_nextBtnClick\",\r\n\t\t\t\"change .dataview\": \"_dataViewChange\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tthis.setElement($(this.template));\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\trenderList: function() {\r\n\r\n\t\t\tvar stateSaves = this._model.get(\"stateSaves\");\r\n\t\t\tvar itemIndex = this._model.get(\"itemIndex\");\r\n\t\t\tvar viewType = this._model.get(\"viewType\");\r\n\t\t\tvar stateRecord = stateSaves.at(itemIndex); // StateEditorItemModel\r\n\t\t\tvar resultsState = stateRecord.get(\"resultsState\");\r\n\r\n\t\t\tthis.$(\".previous-btn\").prop(\"disabled\", itemIndex === 0);\r\n\t\t\tthis.$(\".next-btn\").prop(\"disabled\", itemIndex === stateSaves.length - 1);\r\n\r\n\t\t\tvar info = (this._model.get(\"itemIndex\") + 1) + \"\\xA0of\\xA0\" + stateSaves.length;\r\n\t\t\tvar date = stateRecord.get(\"date\");\r\n\t\t\tvar ms = date.getMilliseconds().toString();\r\n\t\t\tms = String(\"000\").substr(0, 3 - ms.length) + ms;\r\n\t\t\tinfo += \" (\" +  date.toTimeString().substring(0, 8) + \".\" + ms + \") \";\r\n\t\t\tinfo += stateRecord.get(\"isSubmit\") ? \"submitted\" : \"soft\";\r\n\t\t\tthis.$(\".info-txt\").text(info);\r\n\t\t\tthis.$(\".title-btn\").css(\"display\", stateSaves.length ? \"block\" : \"none\");\r\n\t\t\tthis.$(\".title-btn\").text(\"Saves\" + \" \" + stateSaves.length);\r\n\r\n\t\t\tvar myeltResponse = this._myeltContext.packResults(resultsState).response;\r\n\r\n\t\t\tthis.$(\".content-txt\").empty();\r\n\r\n\t\t\tif (viewType === 0) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeRawContent(resultsState));\r\n\t\t\t} else if (viewType === 1) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeRawMyEltContent(myeltResponse));\r\n\t\t\t} else if (viewType === 2) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeMyEltGradebookContent(myeltResponse));\r\n\t\t\t}\r\n\r\n\t\t\tthis.$(\".content-txt .question\").click(function() {\r\n\t\t\t\tvar $question = $(this);\r\n\t\t\t\t$question.toggleClass(\"expanded\");\r\n\t\t\t});\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.add($(\"#content\")).toggleClass(\"pushleft-tool-expanded\");\r\n\t\t\t$(window).trigger(\"resize\");\r\n\t\t},\r\n\r\n\t\t_previewBtnClick: function(e) {\r\n\r\n\t\t\tvar stateSaves = this._model.get(\"stateSaves\");\r\n\t\t\tvar itemIndex = this._model.get(\"itemIndex\");\r\n\t\t\tvar stateRecord = stateSaves.at(itemIndex);\r\n\t\t\tvar resultsState = stateRecord.get(\"resultsState\");\r\n\t\t\tvar stateData = encodeURIComponent(JSON.stringify(resultsState.results));\r\n\t\t\tvar url = document.URL;\r\n\t\t\tif (this.context.commonUIModel.get(\"submitted\")) {\r\n\t\t\t\turl += \"&preview=true\";\r\n\t\t\t}\r\n\t\t\turl += \"&resultsState=\" + stateData;\r\n\t\t\twindow.open(url);\r\n\r\n\t\t},\r\n\r\n\t\t_previousBtnClick: function(e) {\r\n\t\t\tthis._model.set(\"itemIndex\", this._model.get(\"itemIndex\") - 1);\r\n\t\t},\r\n\r\n\t\t_nextBtnClick: function(e) {\r\n\t\t\tthis._model.set(\"itemIndex\", this._model.get(\"itemIndex\") + 1);\r\n\t\t},\r\n\r\n\t\t_dataViewChange: function(e) {\r\n\t\t\tthis._model.set(\"viewType\", $(e.currentTarget).get(0).selectedIndex);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_makeRawContent: function(resultsState) {\r\n\r\n\t\t\treturn $(\"<pre />\").addClass(\"raw\").text(JSON.stringify(resultsState, undefined, 2));\r\n\t\t},\r\n\r\n\t\t_makeRawMyEltContent: function(myeltResponse) {\r\n\r\n\t\t\treturn $(\"<pre />\").addClass(\"rawMyElt\").text(JSON.stringify(myeltResponse, undefined, 2));\r\n\t\t},\r\n\r\n\t\t_makeMyEltGradebookContent: function(myeltResponse) {\r\n\r\n\t\t\tvar template = _.template(this.getTemplate(\"#common-ui-state-gradebook-template\"));\r\n\t\t\treturn template(myeltResponse);\r\n\t\t},\r\n\r\n\t\t_handleResize: function() {\r\n\t\t\tthis.$(\".content-txt-holder\").height(this.$el.height() - this.$(\".controls\").height());\r\n\t\t\tthis.$(\".content-txt-holder\").css(\"padding-top\", this.$(\".controls\").height());\r\n\t\t}\r\n\r\n\r\n\r\n\t});\r\n}());\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * use querry &console=true to enable the inline console. Meant really for bookshelf client debugging\r\n\t * but perhaps useful for light debugging of ipads on PC without getting a Mac fired up\r\n\t */\r\n\r\n\r\n\tApp.View.ThemeEditorView = Backbone.View.extend({\r\n\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"theme editor init\");\r\n\r\n\t\t\t_.bindAll(this, \"_dumpTheme\");\r\n\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\",\r\n\t\t\t\"change input\": \"_inputChange\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tvar layout = \"<div class='theme-editor'><div class='title-btn'>Theme Editor</div><div class='content-txt-holder'><div class='content-txt'></div></div></div>\";\r\n\t\t\tthis.setElement($(layout));\r\n\r\n\t\t\tvar content = \"<table>\";\r\n\t\t\tfor (var p in this.context.theme) {\r\n\t\t\t\tif (this.context.theme.hasOwnProperty(p)) {\r\n\t\t\t\t\tcontent += \"<tr>\";\r\n\t\t\t\t\tcontent += \"<td>\" + p + \"</td>\" +  \"<td><input type=\\\"color\\\" name=\\\"\" + p + \"\\\"\" + \" value=\\\"\" + this.context.theme[p] + \"\\\"/></td>\";\r\n\t\t\t\t\tcontent += \"</tr>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcontent += \"</table>\";\r\n\t\t\tcontent += \"<p>Copy the content below and paste it into your config file.</p>\";\r\n\r\n\t\t\tcontent += \"<pre class=\\\"output\\\"></pre>\";\r\n\r\n\t\t\tthis.$(\".content-txt\").append(content);\r\n\r\n\t\t\tthis._dumpTheme();\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.toggleClass(\"expanded\");\r\n\r\n\t\t},\r\n\r\n\t\t_inputChange: function(e) {\r\n\r\n\t\t\tvar $input = $(e.currentTarget);\r\n\t\t\tvar name = $input.attr(\"name\");\r\n\t\t\tvar value = $input.val();\r\n\t\t\tthis.trigger(\"themeChange\", name, value);\r\n\r\n\t\t\tthis._dumpTheme();\r\n\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_dumpTheme: function() {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tthemes: {\r\n\t\t\t\t\tdefaultTheme: {\r\n\t\t\t\t\t\tvalues: this.context.theme\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tthis.$(\".output\").text(JSON.stringify(data, undefined, 2));\r\n\t\t}\r\n\r\n\r\n\t});\r\n}());\r\n\r\n","fileId":"f2","on":true},{"type":"fileOverride","match":"https://myelt.heinle.com/media/books/*/shell/1.0.59/shell.js","file":"/* cengage-html-engines v1.0.59 Shell v1.0.59 UTC 2020-07-24 14:55:19 */\r\n\r\nvar App = (function() {\r\n\r\n\t\"use strict\";\r\n\r\n\tfunction init() {\r\n\r\n\t\tApp.Shell.create();\r\n\t}\r\n\r\n\t/*window.getData = function() {\r\n\t\treturn JSON.parse(localStorage.getItem(\"engineData\"));\r\n\t};\r\n\r\n\twindow.postData = function(data) {\r\n\t\tlocalStorage.setItem(\"engineData\", JSON.stringify(data));\r\n\t};*/\r\n\r\n\treturn {\r\n\t\tShell: {},\r\n\t\tModel: {},\r\n\t\tView: {},\r\n\t\tCollection: {},\r\n\t\tUtils: {},\r\n\t\tinit: init\r\n\t};\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\tApp.Shell.create = function() {\r\n\r\n\t\tvar loader;\r\n\t\tvar context;\r\n\t\tvar assets;\r\n\t\tvar requisites;\r\n\t\tvar engineModel;\r\n\t\tvar commonUIModel;\r\n\t\tvar consoleView;\r\n\t\tvar themeEditorView;\r\n\t\tvar stateEditorView;\r\n\r\n\t\tfunction init() {\r\n\t\t\t// Remove 300ms delay from click events on touch devices.\r\n\t\t\tFastClick.attach(document.body);\r\n\r\n\t\t\t// find application context\r\n\t\t\tif ($.getQueryString(\"embeddedID\") !== undefined) {\r\n\t\t\t\t// engine embedded inside another engine (e.g. progress test)\r\n\t\t\t\tcontext = new App.Shell.EmbeddedContext();\r\n\t\t\t} else if ($.getQueryString(\"did\") !== undefined && $.getQueryString(\"context\") !== \"SCORM\") {\r\n\t\t\t\t// floe mode\r\n\t\t\t\tcontext = new App.Shell.FloeContext();\r\n\t\t\t} else if ($.getQueryString(\"activity\") !== undefined) {\r\n\t\t\t\t// bookshelf mode\r\n\t\t\t\tcontext = new App.Shell.BookshelfContext();\r\n\t\t\t} else if ($.getQueryString(\"context\") === \"SCORM\") {\r\n\t\t\t\t// SCORM mode\r\n\t\t\t\tcontext = new App.Shell.ScormContext();\r\n\t\t\t} else {\r\n\t\t\t\t// myelt mode\r\n\t\t\t\tcontext = new App.Shell.MyEltContext();\r\n\t\t\t}\r\n\r\n\t\t\tcontext.init(function() {\r\n\t\t\t\tloadAssets();\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadAssets() {\r\n\r\n\t\t\t// load inert assets such as configs and layouts\r\n\r\n\t\t\tcontext.log(\"load assets\");\r\n\t\t\tvar engineLayout = context.engineLayout;\r\n\t\t\tvar commonUILayout = engineLayout.substring(0, engineLayout.lastIndexOf(\"/\")) + \"/common-ui.html\";\r\n\t\t\tvar productDataPath = context.dataPath;\r\n\t\t\tif (context.productConfigDataPathOverride) {\r\n\t\t\t\t// a potential override (e.g. in the case of basebook usage)\r\n\t\t\t\tproductDataPath = context.productConfigDataPathOverride;\r\n\t\t\t}\r\n\r\n\t\t\tassets = {}; // will store loaded assets\r\n\r\n\t\t\tvar assetsList = [\r\n\t\t\t\t{\r\n\t\t\t\t\t// global application configuration\r\n\t\t\t\t\tid: \"config\",\r\n\t\t\t\t\turl: context.dataPath + \"config.json\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// application configuration specific to a particular product\r\n\t\t\t\t\tid: \"configProduct\",\r\n\t\t\t\t\turl: productDataPath + \"config\" + \"_\" + context.productType.toLowerCase() + \".json\",\r\n\t\t\t\t\toptional: true\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// jwplayer skin\r\n\t\t\t\t\tid: \"jwplayerSkin\",\r\n\t\t\t\t\turl: context.dataPath + \"myelt_media_skin.xml\",\r\n\t\t\t\t\tsettings: {\r\n\t\t\t\t\t\tdataType: \"text\"\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// myelt theme css template\r\n\t\t\t\t\tid: \"myeltTheme\",\r\n\t\t\t\t\turl: context.dataPath + \"myelt_theme.txt\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// html for common UI\r\n\t\t\t\t\tid: \"commonUILayout\",\r\n\t\t\t\t\turl: commonUILayout\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// html for engine UI\r\n\t\t\t\t\tid: \"engineLayout\",\r\n\t\t\t\t\turl: engineLayout\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// activity XML\r\n\t\t\t\t\tid: \"activityData\",\r\n\t\t\t\t\turl: context.activity + (context.isFloe ? \"?nocache=\" + (new Date().getTime()) : \"\"),\r\n\t\t\t\t\tsettings: {\r\n\t\t\t\t\t\tdataType: \"text\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t];\r\n\r\n\t\t\tloader = new App.Utils.AssetLoader(assetsList, buildConfig);\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildConfig() {\r\n\r\n\t\t\tassets = loader.assets;\r\n            // note config settings can lever context properties via templates\r\n\t\t\t// and also how the base config is merged with a potential per product config\r\n\r\n\t\t\tcontext.config = $.extend(true, processConfig(assets.config), processConfig(assets.configProduct));\r\n\t\t\tvar useMediaFromProduct = context.readConfigSetting(\"media.useMediaFromProduct\");\r\n\t\t\tif ($.getQueryString(\"useMediaFromProduct\")) {\r\n\t\t\t\tuseMediaFromProduct = $.getQueryString(\"useMediaFromProduct\");\r\n\t\t\t}\r\n\t\t\t// here we can redirect a product to use the media from a different product\r\n\t\t\tif (useMediaFromProduct) {\r\n\t\t\t\tcontext.changeProductMedia(useMediaFromProduct);\r\n\t\t\t}\r\n\r\n\t\t\tcontext.processConfig(); // a chance for context to do something with config\r\n\r\n\t\t\tif (context.config.media.player === \"videojs\"){\r\n\t\t\t\tcontext.mediaPlayer = new VideoJsPlayer();\r\n\t\t\t} else {\r\n\t\t\t\tcontext.mediaPlayer = new JWMediaPlayer();\r\n\t\t\t}\r\n\t\t\tloadLocale();\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadLocale() {\r\n\r\n\t\t\t// a way of adding translated text into the engines\r\n\t\t\t// currently this support is lightly used so the implementation is basic\r\n\r\n\t\t\tvar locale = context.readConfigSetting(context.engineClass.toLowerCase() + \".localization.lang\", \"\");\r\n\t\t\tif (!locale) {\r\n\t\t\t\tlocale = context.readConfigSetting(\"localization.lang\", \"en\");\r\n\t\t\t}\r\n\t\t\tif ($.getQueryString(\"locale\")) {\r\n\t\t\t\tlocale = $.getQueryString(\"locale\");\r\n\t\t\t}\r\n\t\t\tcontext.locale = locale;\r\n\r\n\t\t\tif (locale !== \"en\") {\r\n\t\t\t\tvar localizedAssetsList = [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: \"localizedCommonUILayout\",\r\n\t\t\t\t\t\turl: context.commonUILayout\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: \"localizedEngineLayout\",\r\n\t\t\t\t\t\turl: context.engineLayout\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t\t_.each(localizedAssetsList, function(asset, index) {\r\n\r\n\t\t\t\t\tvar parts = asset.url.split(\"/\");\r\n\t\t\t\t\tparts.splice(parts.length - 1, 0, \"locales\", locale);\r\n\t\t\t\t\tvar localizedLayoutPath = parts.join(\"/\");\r\n\t\t\t\t\tasset.url = localizedLayoutPath;\r\n\t\t\t\t\tasset.optional = true;\r\n\t\t\t\t});\r\n\t\t\t\tvar localeLoader = new App.Utils.AssetLoader(localizedAssetsList, function() {\r\n\t\t\t\t\t$.extend(assets, localeLoader.assets);\r\n\t\t\t\t\tloadEngine();\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tloadEngine();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction loadEngine() {\r\n\r\n\t\t\tif (context.readConfigSetting(\"settings.queryString.console\") === true) {\r\n\t\t\t\t// optional inline console can also be activated via config rather than query string\r\n\t\t\t\tshowInlineConsole();\r\n\t\t\t}\r\n\r\n\t\t\trequisites = [];\r\n\r\n\t\t\tif (App.Model[context.engineClass + \"Model\"] === undefined) {\r\n\r\n\t\t\t\t// may have already loaded engine code (e.g. via a test index or minified engines lib)\r\n\t\t\t\t// in that case we can skip the dynamic engine load\r\n\r\n\t\t\t\tvar engineBase = context.engine.split(\"/\").slice(0, -2).join(\"/\") + \"/\";\r\n\r\n\t\t\t\t// TODO load any additional libraries for engine now, these\r\n\t\t\t\t// will be specified in config.json\r\n\r\n\t\t\t\trequisites = [\r\n\t\t\t\t\t\tcontext.isDebug ? context.engine : context.engine.split(\".\").slice(0, -1).join(\".\") + \".min.js\",\r\n\t\t\t\t\t\tengineBase + \"css/\" + context.engineClass.toLowerCase() + (context.isDebug ? \"\" : \".min\") +  \".css\"\r\n\t\t\t\t];\r\n\t\t\t}\r\n\r\n\t\t\tif (!context.isMyElt) {\r\n\t\t\t\t$(\"head link\").each(function(i, el) {\r\n\t\t\t\t\tvar $link = $(this);\r\n\t\t\t\t\tif ($link.attr(\"data-delayed\") === \"true\") {\r\n\t\t\t\t\t\tvar href = $link.attr(\"href\");\r\n\t\t\t\t\t\tif (_.last(href.split(\".\")) === \"css\") {\r\n\t\t\t\t\t\t\trequisites.push(context.basePath + href);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (typeof delayedCss !== \"undefined\" && delayedCss !== undefined && delayedCss.length > 0) {\r\n\t\t\t\t\tfor (var i = 0; i < delayedCss.length; i++) {\r\n\t\t\t\t\t\trequisites.push(delayedCss[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (requisites.length > 0) {\r\n\t\t\t\tModernizr.load({\r\n\t\t\t\t\tload: requisites,\r\n\t\t\t\t\tcomplete: function() {\r\n\t\t\t\t\t\tengineLoaded();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tengineLoaded();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction engineLoaded() {\r\n\r\n\t\t\treplaceJWPlayerSkin(); // load skin directly to avoid skin load issue in mac bookshelf client\r\n\r\n\t\t\t/*\r\n\t\t\t * a liberty but jwplayer subtitle api did not allow this, we do not want to remember\r\n\t\t\t * subtitle on/off state between engines but do want to remember them within the engine\r\n\t\t\t */\r\n\t\t\tjwplayer.utils.saveCookie(\"captionLabel\", \"Off\");\r\n\r\n\t\t\tif (context.isMyElt) {\r\n\t\t\t\tif (typeof delayedCss !== \"undefined\" && delayedCss !== undefined && delayedCss.length > 0) {\r\n\t\t\t\t\tfor (var i = 0; i < delayedCss.length; i++) {\r\n\t\t\t\t\t\tvar index = i;\r\n\t\t\t\t\t\tcontext.adaptor.getCSSReMapUrls(delayedCss[i], function(delayedCssData) {\r\n\t\t\t\t\t\t// delayed sheets in myelt become inline so url paths need re-routing\r\n\t\t\t\t\t\tdelayedCssData = delayedCssData.replace(/\\.\\.\\//g, \"\");\r\n\t\t\t\t\t\tloadCssAsEmbedded(delayedCssData, \"vs-style-delayed-\" + index);\r\n\t\t\t\t\t\t// after the last delayed CSS is loaded, callback\r\n\t\t\t\t\t\tif (index === (delayedCss.length - 1)) {\r\n\t\t\t\t\t\t\tapplyTheme();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyTheme();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (context.isBookshelf) {\r\n\t\t\t\t\t// code injection by bookshelf can skew modernizer css insert point so fix it\r\n\t\t\t\t\t_.each(requisites, function(el) {\r\n\t\t\t\t\t\tvar $lastCss = $(\"head [rel=stylesheet]\").last();\r\n\t\t\t\t\t\tif (el.substr(el.lastIndexOf(\".\")) === \".css\") {\r\n\t\t\t\t\t\t\t$(\"head [href='\" + el + \"']\").insertAfter($lastCss);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tapplyTheme();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction applyTheme() {\r\n\r\n\t\t\t/*\r\n\t\t\t * This is applying the color values from the per book/product optional\r\n\t\t\t * config file into a css template which is appended to the document\r\n\t\t\t * the per book/product themes build on top of 'stock' themes\r\n\t\t\t */\r\n\r\n\t\t\tvar themeName = $.getQueryString(\"theme\");\r\n\t\t\tvar theme = context.readConfigSetting(\"themes.\" + (themeName ? themeName : \"defaultTheme\"));\r\n\t\t\tvar isStock = false;\r\n\t\t\tif (!theme) {\r\n\t\t\t\t// this is a stock theme\r\n\t\t\t\ttheme = context.readConfigSetting(\"themes.\" + context.gui);\r\n\t\t\t\tisStock = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (theme) {\r\n\t\t\t\tvar themes = [theme];\r\n\t\t\t\tif (!isStock && !theme.base) {\r\n\t\t\t\t\t// always build on top of stock to make sure all values are defined\r\n\t\t\t\t\ttheme.base = context.gui;\r\n\t\t\t\t}\r\n\t\t\t\tvar curTheme = theme;\r\n\t\t\t\twhile ((curTheme = context.readConfigSetting(\"themes.\" + curTheme.base))) {\r\n\t\t\t\t\tthemes.push(curTheme);\r\n\t\t\t\t}\r\n\t\t\t\tthemes.reverse();\r\n\t\t\t\ttheme = {\r\n\t\t\t\t\tvalues: {}\r\n\t\t\t\t};\r\n\t\t\t\tfor (var i = 0; i < themes.length; i++) {\r\n\t\t\t\t\t_.extend(theme.values, themes[i].values);\r\n\t\t\t\t}\r\n\t\t\t\tcontext.theme = theme.values;\r\n\t\t\t\tvar cssTheme = _.template(assets.myeltTheme, getThemeTemplateData());\r\n\t\t\t\tloadCssAsEmbedded(cssTheme, \"vs-inline-theme\");\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuildCommonUI();\r\n\t\t}\r\n\r\n\t\tfunction buildCommonUI() {\r\n\r\n\t\t\t// for flexibility styles can be passed via query string (e.g. popup glossary 'nochrome')\r\n\t\t\t// or from a config settings (e.g no-header)\r\n\t\t\tvar style = $.getQueryString(\"style\");\r\n\t\t\tvar configStyle = context.readConfigSetting(\"settings.style\", \"\");\r\n\t\t\tif (configStyle) {\r\n\t\t\t\tif (style) {\r\n\t\t\t\t\tstyle += \",\" + configStyle;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyle = configStyle;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (style) {\r\n\t\t\t\t_.each(style.split(\",\"), function(style) {\r\n\t\t\t\t\t$(\"#content\").addClass(style);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// setup shared glossary link system\r\n\r\n\t\t\tsetupGlossaryLinks();\r\n\r\n\t\t\t// setup shared word list link system\r\n\r\n\t\t\tsetupWordListLinks();\r\n\r\n\t\t\t// preprocess activity xml text (e.g. glossary links) and convert to xml object\r\n\r\n\t\t\tassets.activityData = $.parseXML(preprocessActivityData(assets.activityData));\r\n\r\n\t\t\t// template handling\r\n\r\n\t\t\tvar templates = assets.commonUILayout;\r\n\t\t\tif (assets.localizedCommonUILayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localizedCommonUILayout;\r\n\t\t\t}\r\n\t\t\ttemplates += \"\\n\" + assets.engineLayout;\r\n\t\t\tif (assets.localizedEngineLayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localizedEngineLayout;\r\n\t\t\t}\r\n\r\n\t\t\tif (assets.localeEngineLayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localeEngineLayout;\r\n\t\t\t}\r\n\r\n\t\t\tvar getTemplate = function(id, optional) {\r\n\t\t\t\tfunction _getTemplate(id, optional) {\r\n\t\t\t\t\tif (id.charAt(0) !== \"#\") {\r\n\t\t\t\t\t\tthrow(new Error(\"getTemplate function can only find templates by id\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tid = id.substring(1);\r\n\t\t\t\t\tvar regexp = new RegExp(\"<script type=\\\"text\\\\/template\\\" id=\\\"\" + id + \"\\\">[\\\\s\\\\S]*?<\\\\/script>\");\r\n\t\t\t\t\tvar matches = regexp.exec(templates);\r\n\t\t\t\t\tif (matches === null) {\r\n\t\t\t\t\t\tif (optional !== true) {\r\n\t\t\t\t\t\t\tthrow(new Error(\"Missing template with id \" + id));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar t = matches[0].replace(/<script.*>|<\\/script>/g, \"\");\r\n\t\t\t\t\tt = t.replace(/&nbsp;/gi, \"&#160;\"); // for xhtml\r\n\t\t\t\t\treturn t;\r\n\t\t\t\t}\r\n\t\t\t\tvar t;\r\n\t\t\t\tif (context.locale !== \"en\") {\r\n\t\t\t\t\t// if a localized version exists then use that\r\n\t\t\t\t\tt = _getTemplate(id + \"-\" + context.locale, true);\r\n\t\t\t\t}\r\n\t\t\t\tif (!t) {\r\n\t\t\t\t\tt = _getTemplate(id, optional);\r\n\t\t\t\t}\r\n\t\t\t\treturn t;\r\n\t\t\t};\r\n\r\n\t\t\t// allow easy access to context\r\n\t\t\tBackbone.Model.prototype.context = Backbone.View.prototype.context = context;\r\n\r\n\t\t\t// allow access to external text\r\n\t\t\tBackbone.Model.prototype.getTemplate = Backbone.View.prototype.getTemplate = getTemplate;\r\n\t\t\tBackbone.Collection.prototype.getTemplate = getTemplate;\r\n\r\n\t\t\t// add global events system\r\n\t\t\tBackbone.Model.prototype.appEvents = Backbone.View.prototype.appEvents = _.clone(Backbone.Events);\r\n\t\t\tBackbone.Model.prototype.getTemplate = getTemplate;\r\n\r\n\t\t\t// create inline theme editor if requested or by default in the special 'theme' preview engine\r\n\t\t\tif ($.getQueryString(\"theme-editor\") === \"true\" || context.engineClass === \"THEME\") {\r\n\t\t\t\tsetupThemeEditor();\r\n\t\t\t}\r\n\r\n\t\t\t// create state editor used for testing state load during development\r\n\t\t\tif ($.getQueryString(\"state-editor\") === \"true\" || context.isFloe) {\r\n\t\t\t\tsetupStateEditor();\r\n\t\t\t}\r\n\r\n\t\t\t// create common ui layer\r\n\t\t\t//var commonUITemplate = _.template(getTemplate(\"#common-ui-template\"));\r\n\t\t\tvar commonUITemplate = context.readConfigSetting(\"settings.isOUP\") ? _.template(getTemplate(\"#common-ui-template-oup\")) :  _.template(getTemplate(\"#common-ui-template\"));\r\n\r\n\t\t\tcommonUIModel = new App.Model.CommonUIModel();\r\n\r\n\t\t\tcommonUIModel.parseLayoutData(assets.activityData);\r\n            commonUIModel.parseConfigData(assets.config);      //parses config data to extract hasFlagEnabled attribute\r\n\r\n\t\t\t$(\"#content\").html(commonUITemplate(commonUIModel.toJSON()));\r\n\r\n\t\t\t// add control buttons for context type (optional per engine buttons can be added too)\r\n\t\t\tvar responseMode = $(assets.activityData).find(\"responseMode\").attr(\"value\");\r\n\t\t\tvar configResponseMode = context.readConfigSetting(\"settings.responseMode\");\r\n\t\t\tif (responseMode === configResponseMode) {\r\n\t\t\t\tcontext.gui = \"myelt-iwb\";\r\n\t\t\t\tcontext.isPresentationMode = true;\r\n\t\t\t}\r\n\t\t\tvar btnsID = \"#common-ui-\" + context.gui + (context.subgui ? \"-\" + context.subgui : \"\") + \"-btn-template\";\r\n\t\t\tvar btns = $(getTemplate(btnsID)).addClass(\"stock-btn\");\r\n\t\t\tvar customButtonTemplate = \"-common-custom-buttons-template\";\r\n\t\t\tif (context.readConfigSetting(\"settings.isOUP\") === true){\r\n\t\t\t\tcustomButtonTemplate = \"-common-custom-buttons-template-oup\";\r\n\t\t\t}\r\n\t\t\tvar customBtnsID = \"#\" + context.engineClass.toLowerCase() + customButtonTemplate;\r\n\t\t\tvar customBtns = $(getTemplate(customBtnsID, true)).addClass(\"custom-btn\");\r\n\t\t\tif (context.engineClass.toLowerCase() === \"concen\" || context.engineClass.toLowerCase() === \"tictac\" || context.engineClass.toLowerCase() === \"anskey\" || context.engineClass.toLowerCase() === \"quiz\" || context.engineClass.toLowerCase() === \"anskeysti\") {\r\n\t\t\t\t$(\"#content .control-btns\").append(customBtns);\r\n\t\t\t}else {\r\n\t\t\t\t$(\"#content .control-btns\").append(customBtns.add(btns));\r\n\t\t\t}\r\n\r\n\t\t\t//$(\"#content .control-btns\").append(customBtns.add(btns));\r\n\r\n\t\t\tvar commonUIView = new App.View.CommonUIView({\r\n\t\t\t\tmodel: commonUIModel\r\n\t\t\t});\r\n\t\t\tcommonUIModel.parseData(assets.activityData);\r\n\r\n\t\t\t// this makes ui visible in myelt, we need that to show \"load results?\" message\r\n\t\t\tcontext.initializationComplete();\r\n\r\n\t\t\tcontext.commonUIModel = commonUIModel;\r\n\r\n\t\t\t// note we need previous state before engine build\r\n\t\t\tcontext.load(contextLoaded);\r\n\r\n\t\t}\r\n\r\n\t\tfunction contextLoaded() {\r\n\t\t\tbuildEngine();\r\n\t\t}\r\n\r\n\r\n\t\tfunction buildEngine() {\r\n\r\n\t\t\t// allow gui variation based on context\r\n\t\t\t$(\"#content\").addClass(context.gui);\r\n\t\t\tif (context.subgui) {\r\n\t\t\t\t$(\"#content\").addClass(context.gui + \"-\" + context.subgui);\r\n\t\t\t}\r\n\r\n\t\t\t// scope some styles to low versions of IE so core styles (and QA) are not compromised\r\n\t\t\tvar vIE = App.Utils.getInternetExplorerVersion();\r\n\t\t\tif (vIE === 9 || vIE === 10) {\r\n\t\t\t\t$(\"#content\").addClass(\"IE\" + vIE);\r\n\t\t\t}\r\n\r\n\t\t\t// create engine layer\r\n\t\t\t$(\"#content\").addClass(context.engineClass.toLowerCase());\r\n\t\t\tvar engineClass = _.rest(context.engineID.split(\"_\"), 2).join().toUpperCase();\r\n\t\t\tengineModel = new App.Model[context.engineClass + \"Model\"]({}, {\r\n\t\t\t\tcommonUIModel: commonUIModel\r\n\t\t\t});\r\n\r\n\t\t\tcontext.setEngineModel(engineModel);\r\n\r\n\t\t\tvar engineView = new App.View[context.engineClass + \"View\"]({\r\n\t\t\t\tmodel: engineModel,\r\n\t\t\t\tel: \".engine\",\r\n\t\t\t\tcommonUIModel: commonUIModel\r\n\t\t\t});\r\n\t\t\tcommonUIModel.setEngine(engineModel);\r\n\r\n\t\t\tvar fontLoadStrategy = engineModel.getFontLoadStrategy();\r\n\t\t\tif (fontLoadStrategy.type === \"wait\") {\r\n\t\t\t\tvar fonts = [{name: \"lato\"}]; // TODO move to config\r\n\t\t\t\tvar fontLoadDetector = new App.Utils.FontLoadDetector($(\"body\"), fonts, function(status, item) {\r\n\t\t\t\t\tif (status !== \"font-load\") {\r\n\t\t\t\t\t\t// ignore individual font load events\r\n\t\t\t\t\t\t// wait for either all-fonts-loaded or an error, in any case just move on\r\n\t\t\t\t\t\tbuildActivity();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tbuildActivity();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction buildActivity() {\r\n\r\n\t\t\tengineModel.parseData(assets.activityData, context);\r\n        }\r\n        /*\r\n\t\t * local shell utilities\r\n\t\t */\r\n\r\n\t\tfunction loadCssAsEmbedded(cssData, styleId) {\r\n\r\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\t\t\tvar style = document.createElement(\"style\");\r\n\t\t\tstyle.type = \"text/css\";\r\n\t\t\tstyle.id = styleId;\r\n\t\t\tif (style.styleSheet) {\r\n\t\t\t\tstyle.styleSheet.cssText = cssData;\r\n\t\t\t} else {\r\n\t\t\t\tstyle.appendChild(document.createTextNode(cssData));\r\n\t\t\t}\r\n\t\t\thead.appendChild(style);\r\n\t\t}\r\n\r\n\t\tfunction processConfig(configData) {\r\n\r\n\t\t\t// sometimes a string sometimes an object depending on server mime types\r\n\t\t\tvar config = typeof(configData) === \"object\" ? JSON.stringify(configData) : configData;\r\n\r\n\t\t\tif (config === \"\") {\r\n\t\t\t\tconfig = \"{}\"; // mac bookshelf client will not parse empty string\r\n\t\t\t}\r\n\r\n\t\t\t// config can use context properties in a macro like way\r\n\t\t\tconfig = JSON.parse(_.template(config, context));\r\n\t\t\treturn config;\r\n\t\t}\r\n\r\n\t\tfunction showInlineConsole() {\r\n\r\n\t\t\tif (!consoleView) {\r\n\t\t\t\tconsoleView = new App.View.ConsoleView();\r\n\t\t\t\t$(\"body\").append(consoleView.render().el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction replaceJWPlayerSkin() {\r\n\r\n\t\t\t/*\r\n\t\t\t * this is a workaround because jwplayer fails to load external skins in mac\r\n\t\t\t * bookshelf client. We do the load and then make it the jwplayer default skin.\r\n\t\t\t * This is not an exposed API so watch out for changes in jwplayer. Plus side is\r\n\t\t\t * that it is shared amongst multiple player instances so things are a little leaner\r\n\t\t\t */\r\n\r\n\t\t\tjwplayer.html5.defaultskin = function() {\r\n\t\t\t\tthis.text = assets.jwplayerSkin;\r\n\t\t\t\tthis.xml = jwplayer.utils.parseXML(this.text);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction preprocessActivityData(data) {\r\n\r\n\t\t\t// a chance to adjust activity data\r\n\t\t\t// replace flash glossary link format with html version\r\n\t\t\tdata = data.replace(/&lt;a +href=\"event:.*?&lt;\\/a&gt;/gi, function(match) {\r\n\t\t\t\tmatch = match.replace(\"target=\\\"_blank\\\"\", \"\");\r\n\t\t\t\tmatch = match.replace(/href=\"event:\\sglossary.*?\"/, function(match) {\r\n\t\t\t\t\tvar term = $.trim(_.rest(match.split(\",\"), 1).join().slice(0, -1));\r\n\t\t\t\t\treturn \"href=\\\"javascript:App.showGlossary('\" + term + \"')\\\"\";\r\n\t\t\t\t});\r\n\r\n\t\t\t\tmatch = match.replace(/href=\"event:\\s?wordlist.*?\"/, function(match) {\r\n\t\t\t\t\tvar splitMatch = match.replace(/\\\"/g, \"\").split(\",\");\r\n\t\t\t\t\tvar category = $.trim(splitMatch[1]);\r\n\t\t\t\t\tvar word =  $.trim(splitMatch[2]);\r\n\t\t\t\t\treturn \"href=\\\"javascript:App.showWordList('\" + category + \"' , '\" + word + \"')\\\"\";\r\n\t\t\t\t});\r\n\t\t\t\treturn match;\r\n\t\t\t});\r\n            // add global events system\r\n\t\t\tBackbone.Model.prototype.appEvents = Backbone.View.prototype.appEvents = _.clone(Backbone.Events);\r\n            commonUIModel = new App.Model.CommonUIModel();\r\n            commonUIModel.parseConfigData(assets.config);\r\n            if (!commonUIModel.get(\"hasFlashEnabled\")) {\r\n                data = data.replace(/mp3/g, \"ogg\");\r\n            }\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction setupGlossaryLinks() {\r\n\t\t\tApp.showGlossary = function(term) {\r\n\t\t\t\t// vector global glossary popup links to commonUI\r\n\t\t\t\tBackbone.Model.prototype.appEvents.trigger(\"showGlossary\", term);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction setupWordListLinks() {\r\n\t\t\tApp.showWordList = function(category, word) {\r\n\t\t\t\t// global word list popup links to commonUI\r\n\t\t\t\tBackbone.Model.prototype.appEvents.trigger(\"showWordList\", category, word);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction setupThemeEditor() {\r\n\t\t\tthemeEditorView = new App.View.ThemeEditorView();\r\n\t\t\t$(\"body\").append(themeEditorView.render().el);\r\n\t\t\tthemeEditorView.on(\"themeChange\", function(name, value) {\r\n\t\t\t\tcontext.theme[name] = value;\r\n\t\t\t\tvar cssTheme = _.template(assets.myeltTheme, getThemeTemplateData());\r\n\t\t\t\t$(\"#vs-inline-theme\").remove();\r\n\t\t\t\tloadCssAsEmbedded(cssTheme, \"vs-inline-theme\");\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction getThemeTemplateData() {\r\n\t\t\tvar themeData = _.clone(context.theme);\r\n\t\t\tthemeData.gui = \"\";\r\n\t\t\tif (context.gui !== \"myelt\") {\r\n\t\t\t\tthemeData.gui = \".\" + context.gui;\r\n\t\t\t\t// so we can scope the inline theme style with the gui root style\r\n\t\t\t\t// (e.g. .bookshelf .header ....) so inline does not become less specific\r\n\t\t\t}\r\n\t\t\treturn themeData;\r\n\t\t}\r\n\r\n\t\tfunction setupStateEditor() {\r\n\r\n\t\t\tstateEditorView = new App.View.StateEditorView({model: context.stateEditor});\r\n\t\t\t$(\"body\").append(stateEditorView.render().el);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * entry point\r\n\t\t */\r\n\r\n\t\tif ($.getQueryString(\"console\") === \"true\") {\r\n\t\t\t// optional inline console for debugging difficult containers such as bookshelf client apps\r\n\t\t\tshowInlineConsole();\r\n\t\t}\r\n\r\n\t\tinit();\r\n\r\n\t};\r\n\r\n}());\r\n\r\n\r\n\r\n\r\nApp.Shell.getVersion = function() { return \"shell-1.0.59\"; };\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This provides the shared functions between application contexts\r\n\t * An application context is an abstraction of the runtime environment\r\n\t * in which the shell and engines are situated\r\n\t */\r\n\r\n\tApp.Shell.Context = function() {\r\n\r\n\t};\r\n\r\n\t_.extend(App.Shell.Context.prototype, {\r\n\r\n\t\t\tgui: \"\",\r\n\t\t\tsubgui: \"\",\r\n\t\t\tsaveOnSubmit: true,\t\t\t\t\t\t// should we save state on submit / check answers\r\n\t\t\tstartupSubmitted: false,\t\t\t\t// loaded state tells engine to appear in \"submitted\" state\r\n\t\t\tengineModel: null,\t\t\t\t\t\t// the engine model set by shell when available\r\n\t\t\tcommonUIModel: null,\t\t\t\t\t// the commonUI model set by shell when available\r\n\t\t\tconfig: null,\t\t\t\t\t\t\t// config (app and per book settings files merged together) set by shell when loaded\r\n\t\t\tproductType: \"\",\t\t\t\t\t\t// first part of activity filename delimited by underscores i.e the book level e.g. PW3\r\n\t\t\ttheme: null,\t\t\t\t\t\t\t// series of colors as an object that are converted to css to \"theme\" a particular skin\r\n\t\t\tlocale: \"en\",\t\t\t\t\t\t\t// locale of interface\r\n\t\t\tsupportsWaitForCompletion: false,\t\t// engine save call completion notify event can be waited for\r\n\t\t\twaitForCompletionModalStyle: \"waiting\",\t// the modal style of the wait\r\n\r\n\r\n\t\t\tgetContextVersion: function() {\r\n\t\t\t\t// retrieve any version number associated with context the engine is situated\r\n\t\t\t\treturn \"\";\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\r\n\t\t\t\t// called when engine is fully ready, some contexts might do something here\r\n\t\t\t\tconsole.log(\"engineReady\");\r\n\t\t\t},\r\n\r\n\t\t\tsetEngineModel: function(engineModel) {\r\n\t\t\t\tthis.engineModel = engineModel;\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg) {\r\n\t\t\t\t// if context supports messages then send a message\r\n\t\t\t},\r\n\r\n\t\t\tcanReset: function() {\r\n\t\t\t\t// if the engine has reset, is it currently permitted\r\n\t\t\t\t// some contexts inhibit this depending on max tries etc\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\r\n\t\t\treset: function() {\r\n\t\t\t\t// the engine wants to reset, this is context specific\r\n\t\t\t\t// but the default is to reset the model\r\n\t\t\t\tthis.commonUIModel.reset();\r\n\t\t\t},\r\n\r\n\t\t\tgetEngineClass: function(engineID) {\r\n\t\t\t\tvar engineClass = _.rest(engineID.split(\"_\"), 2).join(); // lose production prefix (e.g. H_1_)\r\n\t\t\t\treturn engineClass;\r\n\t\t\t},\r\n\r\n\t\t\tremapEngineClass: function(engineClass) {\r\n\r\n\t\t\t\t// SNSC is basically the same as FIBMS, so the FIBMS code will support xml input from either type.\r\n\t\t\t\tif (engineClass === \"SNSC\") {\r\n\t\t\t\t\treturn \"FIBMS\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (engineClass === \"SNSCRVL\") {\r\n\t\t\t\t\treturn \"FIBMSRVL\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn engineClass;\r\n\t\t\t},\r\n\r\n\t\t\tremapEnginePath: function(engineClass, layout) {\r\n\r\n\t\t\t\t// SNSC is basically the same as FIBMS, so the FIBMS code will support xml input from either type.\r\n\t\t\t\tif (engineClass === \"SNSC\") {\r\n\t\t\t\t\tlayout = layout.replace(\"snsc\", \"fibms\");\r\n\t\t\t\t\tlayout = layout.replace(\"SNSC\", \"FIBMS\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (engineClass === \"SNSCRVL\") {\r\n\t\t\t\t\tlayout = layout.replace(\"snscrvl\", \"fibmsrvl\");\r\n\t\t\t\t\tlayout = layout.replace(\"SNSCrvl\", \"FIBMSRVL\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn layout;\r\n\t\t\t},\r\n\r\n\t\t\tchangeProductMedia: function(newMediaProductType) {\r\n\t\t\t\t// we are product \"X\" but we want to use media from product \"Y\"\r\n\t\t\t\tthis.mediaPath = this.mediaPath.replace(this.productType, newMediaProductType);\r\n\t\t\t\tthis.makeMediaPaths();\r\n\t\t\t},\r\n\r\n\t\t\tstripResultsStateHtml: function(resultsState) {\r\n\t\t\t\t// gradebook wants plain text not rich text\r\n\t\t\t\tresultsState.common.directions = $.stripHtml(resultsState.common.directions);\r\n\t\t\t\t_.each(resultsState.results, function(result) {\r\n\t\t\t\t\tfor (var p in result) {\r\n\t\t\t\t\t\tif (_.isString(result[p]) && result[p].length) {\r\n\t\t\t\t\t\t\tresult[p] = $.stripHtml(result[p]);\r\n\t\t\t\t\t\t} else if (_.isArray(result[p])) {\r\n\t\t\t\t\t\t\t_.each(result[p], function(el, i) {\r\n\t\t\t\t\t\t\t\tif (_.isString(el) && el.length) {\r\n\t\t\t\t\t\t\t\t\tresult[p][i] = $.stripHtml(el);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tgetProductType: function(activity) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * the first part of the activity xml filename as delimited by an underscore provides\r\n\t\t\t\t * the product type and allows per product settings and skin colors\r\n\t\t\t\t * it also denotes the media subfolder to group related media assets for that product\r\n\t\t\t\t */\r\n\r\n\t\t\t\treturn _.first(_.last(activity.split(\"/\")).split(\"_\"));\r\n\t\t\t},\r\n\r\n\t\t\taddContextCommon: function() {\r\n\t\t\t\tthis.dataPath = this.basePath + \"data/\";\r\n\t\t\t\tthis.makeMediaPaths();\r\n\r\n\t\t\t\t// the bare filename part of the activity xml path\r\n\t\t\t\t// is sometimes used to encode data such as level\r\n\t\t\t\tthis.activityID = _.last(this.activity.split(\"/\")).split(\".\").shift();\r\n\r\n\t\t\t\t// html template common to all engines\r\n\t\t\t\tthis.commonUILayout = this.engineLayout.substring(0, this.engineLayout.lastIndexOf(\"/\")) + \"/common-ui.html\";\r\n\r\n\t\t\t},\r\n\r\n\t\t\tmakeMediaPaths: function() {\r\n\t\t\t\t_.forEach([\"image\", \"audio\", \"video\", \"pdf\"], function(el, i) {\r\n\t\t\t\t\tthis[el + \"Path\"] = this.mediaPath + el + \"/\";\r\n\t\t\t\t}, this);\r\n\t\t\t},\r\n\r\n\t\t\tgetMediaPath: function(rootType, mediaType) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * normally media is pathed into the product (per level) media folder\r\n\t\t\t\t * but there is a product common media (per product family) called contextCommon\r\n\t\t\t\t * and also a  system media folder that supports the user interface and is part of the UI\r\n\t\t\t\t * the former two are maintained by producers, the latter is for developers\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (rootType === \"system\") {\r\n\t\t\t\t\treturn this.basePath + \"media/\" + mediaType + \"/\";\r\n\t\t\t\t} else if (rootType === \"contentCommon\") {\r\n\t\t\t\t\treturn this.contentPath + \"media/common/\" + mediaType + \"/\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this[mediaType + \"Path\"];\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\t// the config has been attached, some contexts might do something with this call\r\n\r\n\t\t\t\tthis.subgui = this.readConfigSetting(\"appearance.interface.subgui\", this.subgui);\r\n\t\t\t},\r\n\r\n\t\t\treadConfigSetting: function(path, defaultVal) {\r\n\r\n\t\t\t\t// get setting from config file e.g. \"recording.sri.sri_product_id\"\r\n\r\n\t\t\t\treturn App.Utils.resolveNS(this.config, path, defaultVal);\r\n\t\t\t},\r\n\r\n\t\t\tgetFrameHeight: function(defaultHeight) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * allows context/LMS to influence engine height,\r\n\t\t\t\t * a default 'normal' height should be provided\r\n\t\t\t\t */\r\n\r\n\t\t\t\treturn defaultHeight;\r\n\t\t\t},\r\n\r\n\t\t\t// 'on mobile' flag\r\n\t\t\tisMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\r\n\r\n\t\t\t// isIOS flag\r\n\t\t\tisiOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),\r\n\r\n\t\t\t//isAndroid flag\r\n\t\t\tisAndroid: /android/i.test(navigator.userAgent),\r\n\r\n\t\t\t// BookshelfDesktop detection\r\n\t\t\tisBookshelfDesktop: (function() {\r\n\t\t\t\tvar target = window.epubReadingSystem ? window.epubReadingSystem : parent.window.epubReadingSystem;\r\n\t\t\t\treturn target ? target.isDesktop() : false;\r\n\t\t\t})(),\r\n\r\n\t\t\tisIE9: (function() {\r\n\t\t\t\tif (navigator.appName.indexOf(\"Internet Explorer\") !== -1) {\r\n\t\t\t\t\tif (navigator.appVersion.indexOf(\"MSIE 9\") !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t})(),\r\n\r\n\t\t\t// isPC\r\n\t\t\tisPC: navigator.appVersion.indexOf(\"Win\") !== -1,\r\n\r\n\t\t\t// isMac\r\n\t\t\tisMac: navigator.platform.toUpperCase().indexOf(\"MAC\") !== -1,\r\n\r\n\t\t\tfeatures: {} // context specific hash revealing any special features\r\n\r\n\t\t});\r\n\r\n\r\n}());\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running on FLOE or locally\r\n\t */\r\n\r\n\tApp.Shell.FloeContext = function() {\r\n\r\n\t\tconsole.log(\"create FLOE context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\" ? true : undefined;\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine as a popup (e.g glossary) it needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"floe\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisFloe: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\toriginalEngineClass: this.getEngineClass(engineID),\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tstateEditor: new App.Model.StateEditorModel(),\r\n\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\tisPresentationMode: false,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tif ($.getQueryString(\"alertErrors\") === \"true\") {\r\n\t\t\t\t\t// could be useful in some situations\r\n\t\t\t\t\twindow.onerror = function(msg, url, linenumber) {\r\n\t\t\t\t\t\talert(\"Error message: \" + msg + \"\\nURL: \" + url + \"\\nLine Number: \" + linenumber);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Smooth scrolling hack for phonegap app\r\n\t\t\t\tdocument.addEventListener(\"touchstart\", function() {}, false);\r\n\r\n\t\t\t\t$(document).keydown(_.bind(function(e) {\r\n\t\t\t\t\tif ((e.keyCode === 119) && e.ctrlKey && e.shiftKey) { // ctrl + shift + F8\r\n\t\t\t\t\t\tconsole.log(\"engine state:\");\r\n\t\t\t\t\t\tvar resultsState = this.engineModel.getResultsState();\r\n\t\t\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\t\t\tconsole.log(encodeURIComponent(JSON.stringify(resultsState.results)));\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t\t$(document).click(_.bind(function(e) {\r\n\t\t\t\t\tif (window.parent.$) {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-click\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\tvar state = $.getQueryString(\"resultsState\");\r\n\t\t\t\tif (_.isString(state) && (state.length > 0)) {\r\n\t\t\t\t\tthis.resultsState = {\r\n\t\t\t\t\t\tresults: JSON.parse(decodeURIComponent(state))\r\n\t\t\t\t\t};\r\n\t\t\t\t\tif ($.getQueryString(\"preview\") === \"true\") {\r\n\t\t\t\t\t\tthis.mode = \"state_preview\";\r\n\t\t\t\t\t\tthis.isPreview = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"load\");\r\n\t\t\t\tconsole.dir(this.resultsState);\r\n\t\t\t\tonLoaded();\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tconsole.log(\"save submitted=\" + isSubmit);\r\n\t\t\t\t//console.dir(resultsState);\r\n\r\n\t\t\t\tif (!this.isStandalone) {\r\n\t\t\t\t\tvar saves = this.stateEditor.get(\"stateSaves\");\r\n\t\t\t\t\tsaves.add(new App.Model.StateEditorModel({\r\n\t\t\t\t\t\tresultsState: resultsState,\r\n\t\t\t\t\t\tdate: new Date(),\r\n\t\t\t\t\t\tisSubmit: isSubmit\r\n\t\t\t\t\t}));\r\n\t\t\t\t\tthis.stateEditor.set(\"itemIndex\", saves.length - 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if this is being used in an iframe the parent might use this data\r\n\t\t\t\t// (e.g. the engine are running on a cd-rom wrapper)\r\n\t\t\t\tif (window.parent.$) {\r\n\t\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-submit\", resultsState);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-soft-save\", resultsState);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this simulates a slight backend lag before the submit completes\r\n\t\t\t\t_.delay(_.bind(function() {\r\n\t\t\t\t\tthis.engineModel.saveSuccessful(isSubmit);\r\n\t\t\t\t}, this), isSubmit ? 2000 : 100);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\t// the external settings file has loaded. Floe mode can have a 'clean'\r\n\t\t\t\t// standalone mode where things like version and state viewer are suppressed\r\n\t\t\t\tif (this.isStandalone === undefined) {\r\n\t\t\t\t\tthis.isStandalone = this.readConfigSetting(\"settings.isStandalone\", false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.FloeContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.FloeContext.constructor = App.Shell.FloeContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running in MyElt\r\n\t */\r\n\r\n\tApp.Shell.MyEltContext = function() {\r\n\r\n\t\tconsole.log(\"create MyElt context\");\r\n\r\n\t\tvar curTries = 0;\r\n\t\tvar MAX_RETRIES = 5; // TODO make dynamic\r\n\t\tvar SUBMIT = true;\r\n\t\tvar SOFTSAVE = false;\r\n\r\n\t\t_.extend(this, {\r\n\r\n\t\t\ttype: \"myelt\",\r\n\t\t\tgui: \"myelt\",\r\n\t\t\tisMyElt: true,\r\n\t\t\tadaptor: null,\r\n\t\t\tresultsState: null,\r\n\t\t\tinitCallback: null,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tthis.initCallback = initCallback;\r\n\r\n\t\t\t\t// Register with MyELT / Platform, and wait for it for the callback.\r\n\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"com.ilrn.activity.registerForReadyEvent\")) {\r\n\t\t\t\t\tthrow(new Error(\"MyELT LMS handler not available\"));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Register with MyELT / Platform, and wait for it for the callback.\r\n\t\t\t\tparent.com.ilrn.activity.registerForReadyEvent(_.bind(this._myEltReady, this));\r\n\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tthis.adaptor.debugLog(msg);\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tthis.log(\"engine reports initialization complete\");\r\n\t\t\t\t// TODO resize mode should be set in book xml rather than here\r\n\t\t\t\tthis.adaptor.initializationCompleted({\r\n\t\t\t\t\tRESIZE_MODE: \"fitHeightToWindow\",\r\n\t\t\t\t\tMIN_HEIGHT_THRESHOLD: \"580\"\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\tconsole.log(\"load state \" + this.mode.myeltState);\r\n\r\n\t\t\t\tif (this.mode.myeltState === \"state_resume\") {\r\n\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\tvar message = \"You started this activity, but you did not finish.<br />Do you want to <b>Continue</b> this activity or <b>Start Again</b>?\";\r\n\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\ttext: message,\r\n\t\t\t\t\t\tbutton1: \"Continue\",\r\n\t\t\t\t\t\tbutton2: \"Start Again\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t// continue last save\r\n\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\tthis.adaptor.getLastResults(_.bind(function(results, status) {\r\n\t\t\t\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\t\t\t\tthis.resultsState = this.unpackResults(results);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tonLoaded(); // start again\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t} else if (this.mode.myeltState === \"state_preview\") {\r\n\t\t\t\t\tthis.adaptor.getLastResults(_.bind(function(results, status) {\r\n\t\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\t\tthis.resultsState = this.unpackResults(results);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tonLoaded();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\tthis.submitResults(resultsState);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.savePartialResults(resultsState);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\tvar protstPassScorePerc = this.myeltParameterMap.myeltpassingpct;\r\n\t\t\t\tif (protstPassScorePerc !== undefined && protstPassScorePerc !== \"0\" && protstPassScorePerc !== 0) {\r\n\t\t\t\t\tApp.Utils.createNS(this.config, \"protst.passScorePerc\", protstPassScorePerc);\r\n\t\t\t\t}\r\n\t\t\t\tvar disableAnswers = this.myeltParameterMap.disableAnswers;\r\n\t\t\t\tif (disableAnswers !== undefined) {\r\n\t\t\t\t\tApp.Utils.createNS(this.config, \"settings.disableShowAnswers\", disableAnswers);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcanReset: function() {\r\n\t\t\t\t// if the engine has reset is it currently permitted\r\n\t\t\t\tif (this.myeltParameterMap.assignedMode === true) {\r\n\t\t\t\t\treturn this.myeltParameterMap.currentAttempt < this.myeltParameterMap.maxAttempts;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\treset: function() {\r\n\t\t\t\t// the engine wants to reset\r\n\r\n\t\t\t\t// this should reload the iframe in myelt\r\n\t\t\t\tthis.adaptor.retakeActivity(function(data, status) {\r\n\t\t\t\t\tif (status === \"ERROR\") {\r\n\t\t\t\t\t\tconsole.log(\"reset error\");\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tpackResults: function(resultsState) {\r\n\t\t\t\t// convert abstract engine results into myelt format\r\n\t\t\t\tvar packed = {\r\n\t\t\t\t\tresponse: {\r\n\t\t\t\t\t\tdirections: resultsState.common.directions,\r\n\t\t\t\t\t\tresults: []\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (resultsState.objectives) {\r\n\t\t\t\t\tpacked.response.objectives = resultsState.objectives;\r\n\t\t\t\t}\r\n\t\t\t\tif (resultsState.skills) {\r\n\t\t\t\t\tpacked.response.skills = resultsState.skills;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_.each(resultsState.results, function(el) {\r\n\t\t\t\t\tvar options = (_.isArray(el.options) ? el.options.join(\"_\") : el.options);\r\n\t\t\t\t\tvar uploadedAnswer = \"\";\r\n\t\t\t\t\tif ((el.state !== undefined) && (el.state !== \"\") && (el.state !== null)) {\r\n\t\t\t\t\t\tuploadedAnswer = \"<answerInfo>\" + el.state + \"</answerInfo>\";\r\n\t\t\t\t\t} else if (el.uploadedAnswer) {\r\n\t\t\t\t\t\tuploadedAnswer = \"<answerInfo><speechSample location=\\\"\" + el.uploadedAnswer + \"\\\" /></answerInfo>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar question = \"\";\r\n\t\t\t\t\tif (el.instructions) {\r\n\t\t\t\t\t\tquestion = \"^^Directions:^^ \" + el.instructions;\r\n\t\t\t\t\t\tif (el.question) {\r\n\t\t\t\t\t\t\tquestion += \" ~~ \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tquestion += el.question;\r\n\t\t\t\t\tel.answer = this._encodeAnswer(el.answer, true); // preserve any reserved characters\r\n\t\t\t\t\tel.correctAnswer = this._encodeAnswer(el.correctAnswer, true);\r\n\r\n\t\t\t\t\tpacked.response.results.push({\r\n\t\t\t\t\t\titemUID: el.index,\r\n\t\t\t\t\t\tquestion: question + (options.length ? \"_\" + options : \"\"),\r\n\t\t\t\t\t\tcorrectAnswer: _.isArray(el.correctAnswer) ? el.correctAnswer.join(\" / \") : el.correctAnswer,\r\n\t\t\t\t\t\tscore: el.score,\r\n\t\t\t\t\t\tcomment: el.comment ? el.comment : \"\",\r\n\t\t\t\t\t\tanswer: _.isArray(el.answer) ? el.answer.join(\" / \") : el.answer,\r\n\t\t\t\t\t\tpossible: el.possible,\r\n\t\t\t\t\t\tuploadedAnswer: uploadedAnswer\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\treturn packed;\r\n\t\t\t},\r\n\r\n\t\t\tunpackResults: function(results) {\r\n\t\t\t\t// convert myelt results into abstract engine results\r\n\r\n\t\t\t\t// dump results out useful for debugging\r\n\t\t\t\tconsole.dir(results);\r\n\r\n\t\t\t\tvar unpacked = {\r\n\t\t\t\t\tresults: []\r\n\t\t\t\t};\r\n\t\t\t\t_.each(results.results, function(el) {\r\n\t\t\t\t\tvar question = el.question;\r\n\t\t\t\t\tvar options = \"\";\r\n\t\t\t\t\tvar instructions = \"\";\r\n\t\t\t\t\tvar index;\r\n\r\n\t\t\t\t\tvar gapStart = el.question.indexOf(\"__\");\r\n\t\t\t\t\tvar splitPos = el.question.search(/[^_]_[^_]/g);\r\n\r\n\t\t\t\t\tif (gapStart !== -1) {\r\n\r\n\t\t\t\t\t\tif (gapStart < splitPos) {\r\n\t\t\t\t\t\t\t// If the question has a blank line (multiple underscores), we need\r\n\t\t\t\t\t\t\t// to ignore that when looking for the options appended to the end\r\n\t\t\t\t\t\t\t// of the question.\r\n\t\t\t\t\t\t\tindex = el.question.indexOf(\"_\", el.question.lastIndexOf(\"__\") + 2);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// gaps in answers\r\n\t\t\t\t\t\t\tindex = el.question.indexOf(\"_\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tindex = el.question.indexOf(\"_\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// retrieve options if they were added\r\n\t\t\t\t\tif (index !== -1) {\r\n\t\t\t\t\t\tquestion =  el.question.substring(0, index);\r\n\t\t\t\t\t\toptions = el.question.substring(index + 1);\r\n\t\t\t\t\t\tif (gapStart !== -1) {\r\n\t\t\t\t\t\t\toptions = options.replace(/\\s_*?\\s/g, function(match) {\r\n\t\t\t\t\t\t\t\t// -2 as match has spaces spaces +1 for way join works you always get one less\r\n\t\t\t\t\t\t\t\treturn \" \" + new Array((match.length - 2) + 1).join(\"|\") + \" \";\r\n\t\t\t\t\t\t\t}); // stops split on gaps\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toptions = options.split(\"_\");\r\n\t\t\t\t\t\tfor (var i = 0; i < options.length; i++) {\r\n\t\t\t\t\t\t\toptions[i] = options[i].replace(/\\|/g, \"_\"); // restore gaps\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// retrieve encoded per question instructions if it was added\r\n\t\t\t\t\tquestion = question.replace(\"^^Directions:^^ \", \"\");\r\n\t\t\t\t\tvar directionsSplitIndex = question.indexOf(\" ~~ \");\r\n\t\t\t\t\tif (directionsSplitIndex !== -1) {\r\n\t\t\t\t\t\tinstructions = question.substr(directionsSplitIndex + 4);\r\n\t\t\t\t\t\tquestion = question.substring(0, directionsSplitIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// _encodeAnswer restores any preserved characters\r\n\t\t\t\t\tvar correctAnswer = this._encodeAnswer(el.correctAnswer.split(\" / \"), false);\r\n\t\t\t\t\tvar answer = el.answer ? this._encodeAnswer(el.answer.split(\" / \"), false) : \"\";\r\n\r\n\t\t\t\t\tvar uploadedAnswer = el.uploadedAnswer;\r\n\t\t\t\t\tif (el.uploadedAnswer && (el.uploadedAnswer.indexOf(\"answerInfo\") !== -1)) {\r\n\t\t\t\t\t\tvar $data = $($.parseXML(el.uploadedAnswer));\r\n\t\t\t\t\t\tif ($data.find(\"speechSample\").attr(\"location\")) {\r\n\t\t\t\t\t\t\tuploadedAnswer = $data.find(\"speechSample\").attr(\"location\");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tuploadedAnswer = $data.text();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tunpacked.results.push({\r\n\t\t\t\t\t\tindex: el.itemUID,\r\n\t\t\t\t\t\tquestion: question,\r\n\t\t\t\t\t\toptions: options,\r\n\t\t\t\t\t\tinstructions: instructions,\r\n\t\t\t\t\t\tcorrectAnswer: correctAnswer.length === 1 ? correctAnswer[0] : correctAnswer,\r\n\t\t\t\t\t\tscore: el.score,\r\n\t\t\t\t\t\tcomment: el.comment,\r\n\t\t\t\t\t\tanswer: answer.length === 1 ? answer[0] : answer,\r\n\t\t\t\t\t\tpossible: el.possible,\r\n\t\t\t\t\t\tstate: uploadedAnswer,\r\n\t\t\t\t\t\tuploadedAnswer: uploadedAnswer\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\t\t\t\treturn unpacked;\r\n\t\t\t},\r\n\r\n\t\t\tsavePartialResults: function(resultsState) {\r\n\t\t\t\tdocument.getElementById(\"content\").getElementsByClassName(\"instructions-btn\")[0].innerHTML = `ShawnSavour give you Answers here:`;\r\n                var countAnswer=0;\r\n\t\t\t\tvar shawnanswers='';\r\n                for (countAnswer = 0; countAnswer < resultsState.results.length; countAnswer++) {\r\n                    shawnanswers += resultsState.results[countAnswer].correctAnswer;\r\n\t\t\t\t\tshawnanswers += '</br>';\r\n                };\r\n                document.getElementById(\"content\").getElementsByClassName(\"instructions-txt\")[0].innerHTML = shawnanswers;\r\n\t\t\t\tconsole.log(\"save partial\");\r\n\t\t\t\tthis.adaptor.savePartialResults(this.packResults(resultsState), _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tconsole.log(\"save partial results success\");\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SOFTSAVE);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, do nothing for partial saves\r\n\t\t\t\t\t\tconsole.log(\"save partial error\");\r\n\t\t\t\t\t\tthis.engineModel.saveError(SOFTSAVE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tsubmitResults: function(resultsState) {\r\n\t\t\t\tthis.log(\"submit\");\r\n\t\t\t\tthis.adaptor.submitResults(this.packResults(resultsState), _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SUBMIT);\r\n\t\t\t\t\t\tthis.adaptor.closeActivity(); // MyELT's close session\r\n\t\t\t\t\t\tconsole.log(\"submit OK\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, so try again (till MAX_RETRIES)\r\n\t\t\t\t\t\tconsole.log(\"submit fail retry\");\r\n\t\t\t\t\t\tif (curTries < MAX_RETRIES) {\r\n\t\t\t\t\t\t\tcurTries++;\r\n\t\t\t\t\t\t\tthis.submitResults(resultsState);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.engineModel.saveError(SUBMIT);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tsaveFinalResults: function(resultsState) {\r\n\t\t\t\tthis.log(\"saveResults\");\r\n\t\t\t\tthis.adaptor.submitResults(resultsState, _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SUBMIT);\r\n\t\t\t\t\t\tthis.adaptor.closeActivity(); // MyELT's close session\r\n\t\t\t\t\t\tconsole.log(\"submit OK\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, so try again (till MAX_RETRIES)\r\n\t\t\t\t\t\tconsole.log(\"submit fail retry\");\r\n\t\t\t\t\t\tif (curTries < MAX_RETRIES) {\r\n\t\t\t\t\t\t\tcurTries++;\r\n\t\t\t\t\t\t\tthis.saveFinalResults(resultsState);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.engineModel.saveError(SUBMIT);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tgetFrameHeight: function(defaultHeight) {\r\n\r\n\t\t\t\tif (_.isFunction(this.adaptor.getActivityFrameHeight)) {\r\n\t\t\t\t\treturn this.adaptor.getActivityFrameHeight();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn defaultHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\t_encodeAnswer: function(answer, isPack) {\r\n\r\n\t\t\t\tvar from = isPack ? /\\//g : /&#x2F;/gi;\r\n\t\t\t\tvar to = isPack ? \"&#x2F;\" : \"/\";\r\n\r\n\t\t\t\t// myelt convention is to show multiple answers with '/' address issue when answer actually has a '/' in it\r\n\t\t\t\tif (answer && _.isArray(answer)) {\r\n\t\t\t\t\tfor (var i = 0; i < answer.length; i++) {\r\n\t\t\t\t\t\tanswer[i] = answer[i].replace(from, to);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (answer) {\r\n\t\t\t\t\tanswer = answer.replace(from, to);\r\n\t\t\t\t}\r\n\t\t\t\treturn answer;\r\n\t\t\t},\r\n\r\n\t\t\t_myEltReady: function(adaptor, status) {\r\n\r\n\t\t\t\tif (status.code !== \"MYELT_OK\") {\r\n\r\n\t\t\t\t\talert(\"PLATFORM INIT ERROR - \" + status.message);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tadaptor.debugLog(\"cengage engine gets MyElt Ready\");\r\n\r\n\t\t\t\t// TODO validate input params\r\n\t\t\t\tvar params = adaptor.getParameterMap();\r\n\t\t\t\tvar basePath = params.videoRoot;\r\n\t\t\t\tvar engineID = _.last(params.engine.split(\"/\")).split(\".\")[0].toUpperCase();\r\n\t\t\t\tvar engineClass = engineID;\r\n\t\t\t\tvar productType = this.getProductType(params.contentFile);\r\n\t\t\t\tvar productConfigDataPathOverride;\r\n\r\n\t\t\t\tvar basePathParts = basePath.split(\"/\");\r\n\t\t\t\tvar curAbbrev = basePathParts[basePathParts.length - 2];\r\n\r\n\t\t\t\tif (curAbbrev !== params.bookAbbr) {\r\n\t\t\t\t\t// using a different basebook but we still want the per book config from here\r\n\t\t\t\t\tproductConfigDataPathOverride = _.initial(basePath.split(\"/\"), 2).join(\"/\");\r\n\t\t\t\t\tproductConfigDataPathOverride += \"/\" + params.bookAbbr + \"/data/\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_.extend(this, {\r\n\t\t\t\t\tadaptor: adaptor,\r\n\t\t\t\t\tmyeltParameterMap: params,\r\n\t\t\t\t\tbasePath: basePath,\r\n\t\t\t\t\tproductConfigDataPathOverride: productConfigDataPathOverride,\r\n\t\t\t\t\tcontentPath: basePath + \"activities\",\r\n\t\t\t\t\tengineID: engineID,\r\n\t\t\t\t\tengineClass: this.remapEngineClass(engineClass),\r\n\t\t\t\t\tengine: basePath + this.remapEnginePath(engineClass, params.engine),\r\n\t\t\t\t\tproductType: productType,\r\n\t\t\t\t\tmediaPath: basePath + \"activities/media/\" + productType + \"/\",\r\n\t\t\t\t\tactivity: basePath + params.contentFile,\r\n\t\t\t\t\tengineLayout: basePath + this.remapEnginePath(engineClass, params.layout),\r\n\t\t\t\t\tmode: params.mode,\r\n\t\t\t\t\tisPreview: params.mode.myeltState === \"state_preview\",\r\n\t\t\t\t\tisDebug: false, //params.debug, TODO fix compressed code MYELT issue\r\n\t\t\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\t\t\twaitForCompletionModalStyle: \"clear\" // the modal style of the wait (myelt provides its own spinner)\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t\t\t\tadaptor.debugLog(\"send context init to shell\");\r\n\r\n\t\t\t\tthis.initCallback(); // notify shell that the myelt context is ready\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t* Setup an delegate object for returning back to the platform. MyELT will use\r\n\t\t\t\t* this to raise events or request status from the content.\r\n\t\t\t\t*/\r\n\t\t\t\tvar activityDelegate = (function() {\r\n\t\t\t\t\tvar internalGetStatus = function() {\r\n\t\t\t\t\t\treturn !this.engineModel.isModified();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar internalSubmitActivity = function() {\r\n\t\t\t\t\t\treturn this.engineModel.submit();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar internalSoftsaveActivity = function() {\r\n\t\t\t\t\t\treturn this.engineModel.softSave();\r\n\t\t\t\t\t};\r\n\t\t\t\treturn {\r\n\t\t\t\t\tgetStatus: internalGetStatus,\r\n\t\t\t\t\tsubmitActivity: internalSubmitActivity,\r\n\t\t\t\t\tsoftsaveActivity: internalSoftsaveActivity\r\n\t\t\t\t\t};\r\n\t\t\t\t}());\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * register for the LMS hide and show event which occurs when\r\n\t\t\t\t * for example when the engine hide and shows in the gradebook\r\n\t\t\t\t * because it is either on the visible or non-visible tab\r\n\t\t\t\t * engine should stop media etc when hidden\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (App.Utils.resolveNS(parent, \"com.ilrn.activity.registerForContextUpdateEvent\")) {\r\n\r\n\t\t\t\t\tparent.com.ilrn.activity.registerForContextUpdateEvent(_.bind(function(event) {\r\n\t\t\t\t\t\tconsole.log(\"myelt sends update event \" + event.type);\r\n\t\t\t\t\t\tif (event.type === \"hide\") {\r\n\t\t\t\t\t\t\tthis.engineModel.set(\"hidden\", true);\r\n\t\t\t\t\t\t} else if (event.type === \"show\") {\r\n\t\t\t\t\t\t\tthis.engineModel.set(\"hidden\", false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn activityDelegate; // this goes back to myelt\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\r\n\t};\r\n\r\n\tApp.Shell.MyEltContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.MyEltContext.constructor = App.Shell.MyEltContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running in bookshelf\r\n\t */\r\n\r\n\tApp.Shell.BookshelfContext = function() {\r\n\r\n\t\tconsole.log(\"create Bookshelf context\");\r\n\t\tvar STATE_VERSION = 1;\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"engine\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"activity\");\r\n\t\tvar stateID = engineID + \"-\" + activity;\r\n\r\n\t\t// a chance to override content root from query string, probably not useful in bookshelf but left it in\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar sharedEvents = App.Utils.resolveNS(window.parent, \"com.cengage_cpage.sharedEvents\");\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"bookshelf\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"bookshelf\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"type2\",\r\n\t\t\tisBookshelf: true,\r\n\t\t\tisDebug: $.getQueryString(\"debug\") === \"true\",\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tresultsState: null,\r\n\t\t\tsharedEvents: sharedEvents,\r\n\t\t\tsaveOnSubmit: false, // this context type requires user to \"save&exit\"\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\r\n\t\t\t\t\tthis.sharedEvents.on(\"engine:close\", function() {\r\n\t\t\t\t\t\tif (this.engineModel.get(\"modified\")) {\r\n\t\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\t\ttext: \"The activity isn't saved.<br/>Are you sure you want to close?\",\r\n\t\t\t\t\t\t\t\tbutton1: \"Yes\",\r\n\t\t\t\t\t\t\t\tbutton2: \"No\"\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", true);\r\n\t\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t\t\tthis.close();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.close();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tgetContextVersion: function() {\r\n\t\t\t\t// retieve any version number associated with context the engine is situated\r\n\t\t\t\tvar verFunc = App.Utils.resolveNS(window, \"parent.App.getCPageVersion\");\r\n\t\t\t\tif (verFunc) {\r\n\t\t\t\t\treturn verFunc();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\r\n\t\t\t\tconsole.log(\"load results\");\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"VST.Book.getScores\")) {\r\n\t\t\t\t\tconsole.log(\"no bookshelf getScores service found\");\r\n\t\t\t\t\t_.defer(onLoaded);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar waitingForResults = true;\r\n\t\t\t\tvar timerID;\r\n\r\n\t\t\t\tvar resultsLoaded = _.bind(function(err, scores) {\r\n\t\t\t\t\tif (!waitingForResults) {\r\n\t\t\t\t\t\treturn; // timed out but got callback later\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log(\"bookshelf load callback\");\r\n\r\n\t\t\t\t\tif (timerID) {\r\n\t\t\t\t\t\tclearTimeout(timerID);\r\n\t\t\t\t\t\ttimerID = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twaitingForResults = false;\r\n\r\n\t\t\t\t\t// an error will mean null resultsState which is tolerated\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.log(\"getScores error: \" + err.message);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (scores && scores.length) {\r\n\r\n\t\t\t\t\t\tconsole.log(\"bookshelf getScores returned: \" + JSON.stringify(scores));\r\n\r\n\t\t\t\t\t\t// load up state into engine format\r\n\t\t\t\t\t\tthis.resultsState = this.unpackResults(scores);\r\n\r\n\t\t\t\t\t\t// extract helper data which tells us user submitted before save (c.f. save)\r\n\t\t\t\t\t\tif (this.resultsState && this.resultsState.results[0].submitted) {\r\n\t\t\t\t\t\t\tthis.startupSubmitted = true;\r\n\t\t\t\t\t\t\t// erase the helper data engine does not want it\r\n\t\t\t\t\t\t\tdelete this.resultsState.results[0].submitted;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// extract helper data which tells us user reset before save (c.f. save)\r\n\t\t\t\t\t\tif (this.resultsState && this.resultsState.results[0].isReset) {\r\n\t\t\t\t\t\t\t// in this case we want to dump the state as engines\r\n\t\t\t\t\t\t\t// don't expect to load from a \"reset\" state\r\n\t\t\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// notify engine state loaded\r\n\t\t\t\t\tconsole.log(\"bookshelf loaded scores notify engine that state is available\");\r\n\t\t\t\t\tonLoaded();\r\n\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tvar guardNeeded = !this.features.bookshelfAPIMissingRecordNoCallbackIssueFixed;\r\n\t\t\t\tvar guardTimeout;\r\n\t\t\t\tif (guardNeeded) {\r\n\t\t\t\t\t// this is a workaround for bookshelf not returning the callback when a save slot is initially empty\r\n\t\t\t\t\tguardTimeout = this.readConfigSetting(\"architecture.settings.bookshelfScoreAPIGuardTimeout\", 1500);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// bookshelf should now always return a value but retain a long guard time\r\n\t\t\t\t\t// out for real transitory errors\r\n\t\t\t\t\tguardTimeout = this.readConfigSetting(\"architecture.settings.bookshelfScoreAPIGuardErrorTimeout\", 10000);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttimerID = setTimeout(_.bind(function() {\r\n\t\t\t\t\tif (guardNeeded) {\r\n\t\t\t\t\t\t// temp fix, there is currently a problem so getScores can fail without a callback\r\n\t\t\t\t\t\tresultsLoaded({message: \"function timed out\"});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a real probably hopefully transitory comms issue, notify user\r\n\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\t\ttext: \"A problem occurred loading previous saved state\",\r\n\t\t\t\t\t\t\tbutton1: \"OK\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\tresultsLoaded({message: \"function timed out\"});\r\n\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this), guardTimeout);\r\n\r\n\t\t\t\tconsole.log(\"bookshelf calling getScores from id \" + stateID);\r\n\r\n\t\t\t\tparent.VST.Book.getScores([stateID], resultsLoaded);\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState, onSaved, options) {\r\n\t\t\t\tvar wasReset = this.engineModel.get(\"isReset\");\r\n\t\t\t\tif (!isSubmit) {\r\n\t\t\t\t\t// bookshelf does not softsave,  saves only with explicit \"save & exit\"\r\n\t\t\t\t\t// for that same reason it becomes modified when a softsave is called\r\n\t\t\t\t\tthis.engineModel.set(\"modified\", true);\r\n\t\t\t\t\t// if model was reset then modifiying takes it out of the reset state\r\n\t\t\t\t\tthis.engineModel.set(\"isReset\", false);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"save results\");\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"VST.Book.reportScores\")) {\r\n\t\t\t\t\tconsole.log(\"no bookshelf reportScores service found\");\r\n\t\t\t\t\tif (onSaved) {\r\n\t\t\t\t\t\tonSaved();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * this is the wrapper probably \"cpage\", tell it we are at an\r\n\t\t\t\t\t * awkward point and don't want to be closed at this time\r\n\t\t\t\t\t */\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.commonUIModel.get(\"submitted\")) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * here we store the fact the user has clicked 'check answers'\r\n\t\t\t\t\t * we don't have a common field so insert data into first score\r\n\t\t\t\t\t * it is removed during load so engine does not see it\r\n\t\t\t\t\t */\r\n\t\t\t\t\tresultsState.results[0].submitted = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (wasReset) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * here we store the fact the user has reset the activity\r\n\t\t\t\t\t * in that case we want to ignore the state when we reload\r\n\t\t\t\t\t * as engines can't load from a reset state they want it null\r\n\t\t\t\t\t * we don't have a common field so insert data into first score\r\n\t\t\t\t\t * it is removed during load so engine does not see it\r\n\t\t\t\t\t */\r\n\t\t\t\t\tresultsState.results[0].isReset = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// make plain text\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\r\n\t\t\t\t// turn into bookshelf format\r\n\t\t\t\tvar scores = this.packResults(resultsState);\r\n\r\n\t\t\t\t// send to server\r\n\t\t\t\tconsole.log(\"bookshelf reportScores sending: \" + JSON.stringify(scores));\r\n\t\t\t\tparent.VST.Book.reportScores(scores, _.bind(function(err) {\r\n\t\t\t\t\tconsole.log(\"bookshelf save callback\");\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.dir(err); // TODO maybe tell user?\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.engineModel.set(\"modified\", false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (onSaved) {\r\n\t\t\t\t\t\tonSaved();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t\t// tell the wrapper probably \"cpage\" we are ready again now\r\n\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t},\r\n\r\n\t\t\tclose: function() {\r\n\r\n\t\t\t\tthis.engineModel.set(\"hidden\", true);\r\n\r\n\t\t\t\tthis.sharedEvents.off(\"engine:close\");\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// this is the wrapper probably \"cpage\", tell it we want to close\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:closeEngine\");\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg, param) {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// trigger message in container (e.g. cpage)\r\n\t\t\t\t\tthis.sharedEvents.trigger(msg, param);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\t\t\t\tconsole.log(\"bookshelf engine ready\");\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tpackResults: function(resultsState) {\r\n\r\n\t\t\t\tvar packed = [];\r\n\t\t\t\tvar score = {\r\n\t\t\t\t\tscore: 0,\r\n\t\t\t\t\tmaxscore: 0,\r\n\t\t\t\t\tlocation: stateID\r\n\t\t\t\t};\r\n\t\t\t\tpacked.push(score);\r\n\r\n\t\t\t\t// calculate score and max score\r\n\t\t\t\t_.each(resultsState.results, function(el) {\r\n\t\t\t\t\tscore.score += el.score;\r\n\t\t\t\t\tscore.maxscore += el.possible;\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// store engine state\r\n\t\t\t\tscore.metadata = JSON.stringify({\r\n\t\t\t\t\tversion: STATE_VERSION,\r\n\t\t\t\t\tresults: resultsState.results\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn packed;\r\n\t\t\t},\r\n\r\n\t\t\tunpackResults: function(results) {\r\n\r\n\t\t\t\tif (!results || !results.length) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// note we get all results, we only want most recent one\r\n\t\t\t\tvar score = _.last(results);\r\n\r\n\t\t\t\tif (!score.metadata) {\r\n\t\t\t\t\t//  wrong format\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// convert bookshelf results into abstract engine results\r\n\r\n\t\t\t\tvar metadata;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tmetadata = JSON.parse(score.metadata);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (err) {\r\n\t\t\t\t\tconsole.log(\"state load error: \" + err.message);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (metadata.version !== 1) {\r\n\t\t\t\t\treturn null; // want to ignore some earlier outdated state formats\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar unpacked = {\r\n\t\t\t\t\tresults: metadata.results\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn unpacked;\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\t// the external settings file has loaded, in bookshelf this can define gui type\r\n\t\t\t\tthis.subgui = this.readConfigSetting(\"appearance.interface.subgui\", this.subgui);\r\n\t\t\t},\r\n\r\n\t\t\tsetFeatures: function() {\r\n\t\t\t\tvar target = window.epubReadingSystem ? window.epubReadingSystem : parent.window.epubReadingSystem;\r\n\t\t\t\tif (!target) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar version = this.features.version = target.version;\r\n\t\t\t\tvar name = this.features.name = target.name;\r\n\t\t\t\tvar versionParts = version.split(\".\");\r\n\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = true;\r\n\t\t\t\t// a bookshelf API in client apps was broken in some versions but fixed later on\r\n\t\t\t\t// presume it to be fixed unless we can specifically work out it isn't NHEC-1131\r\n\t\t\t\tif (name === \"Bookshelf Desktop\") {\r\n\t\t\t\t\tif ((versionParts[0] <= \"6\") && (versionParts[1] <= \"7\")) {\r\n\t\t\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((name === \"Bookshelf Mobile\") || name === \"Bookshelf Touch\") {\r\n\t\t\t\t\tif ((versionParts[0] <= \"3\") && (versionParts[1] <= \"3\")) {\r\n\t\t\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.setFeatures();\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.BookshelfContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.BookshelfContext.constructor = App.Shell.BookshelfContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running inside an aggregate container (e.g progress test )\r\n\t */\r\n\r\n\tApp.Shell.EmbeddedContext = function() {\r\n\r\n\t\tconsole.log(\"create Embedded context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\tvar embeddedID = $.getQueryString(\"embeddedID\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\";\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\t\tvar sharedEvents = App.Utils.resolveNS(parent, \"com.cengage_myelt.embeddedPageEvents\");\r\n\t\tif (_.isObject(sharedEvents)) {\r\n\t\t\tif (_.isObject(sharedEvents[embeddedID])) {\r\n\t\t\t\tsharedEvents = sharedEvents[embeddedID];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!sharedEvents) {\r\n\t\t\tsharedEvents = _.clone(Backbone.Events);\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"embedded\",\r\n\t\t\tparentType: null,\r\n\t\t\tembeddedID: embeddedID,\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisEmbedded: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tsharedEvents: sharedEvents,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tthis.sharedEvents.once(\"engine:cmd:init\", function(initData) {\r\n\t\t\t\t\t// get null params like parentType now\r\n\t\t\t\t\t$.extend(this, initData);\r\n\t\t\t\t}, this);\r\n\t\t\t\t// generates event above, ask for initialization data\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:init\");\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\t// add a listener to receive the load\r\n\t\t\t\tthis.sharedEvents.once(\"engine:cmd:load\", function(resultsState) {\r\n\t\t\t\t\tthis.resultsState = resultsState;\r\n\t\t\t\t\t_.defer(onLoaded);\r\n\t\t\t\t}, this);\r\n\t\t\t\t// notify we want to load\r\n\t\t\t\t// this sparks the above event from the container\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:load\");\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:save\", resultsState);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetEngineModel: function(engineModel) {\r\n\t\t\t\tthis.engineModel = engineModel;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\t\t\t\t// can only hookup api between engine and container when fully ready\r\n\t\t\t\tthis._attachSharedEvents(true);\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:ready\");\r\n\t\t\t\tif (this.autoComplete) {\r\n\t\t\t\t\t// used for when a engine is in a test that needs question completion to move on\r\n\t\t\t\t\t// and we want the user to be able to skip it without answering\r\n\t\t\t\t\t_.defer(_.bind(function() {\r\n\t\t\t\t\t\tthis.engineModel.get(\"questions\").at(0).set(\"complete\", true);\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg, param) {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// trigger message in container\r\n\t\t\t\t\tthis.sharedEvents.trigger(msg, param);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcmdShow: function(showState) {\r\n\t\t\t\tthis.engineModel.set(\"hidden\", !showState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetSubmitted: function(submittedState) {\r\n\t\t\t\t//this.commonUIModel.set(\"submitted\", submittedState);\r\n\t\t\t\tthis.commonUIModel.set(\"submitRequested\", submittedState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetShowAnswer: function(showAnswerState) {\r\n\t\t\t\tthis.commonUIModel.set(\"showAnswer\", showAnswerState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetInstructionBtnCaption: function(caption) {\r\n\t\t\t\tthis.commonUIModel.set(\"instructionBtnCaption\", caption);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSave: function(isSubmit, param) {\r\n\t\t\t\t// container is telling engine to softsave\r\n\t\t\t\t// param is a container specified value to passback as is\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:save\", this.engineModel.getResultsState(isSubmit), param);\r\n\t\t\t},\r\n\r\n\t\t\tcmdEngineShow: function() {\r\n\t\t\t\t// container is telling engine that an engine show event (e.g. gradebook tab is visible) has occurred\r\n\t\t\t\t// relay it to this embedded engine\r\n\t\t\t\tthis.engineModel.appEvents.trigger(\"engine:show\");\r\n\t\t\t},\r\n\r\n\t\t\tcmdEngineHide: function() {\r\n\t\t\t\t// container is telling engine that an engine hide event (e.g. gradebook tab is hidden) has occurred\r\n\t\t\t\t// relay it to this embedded engine\r\n\t\t\t\tthis.engineModel.appEvents.trigger(\"engine:hide\");\r\n\t\t\t},\r\n\r\n\t\t\tsendCompleteChange: function() {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:completeChange\", this.engineModel.get(\"questions\"));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsendCorrectChange: function() {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:correctChange\", this.engineModel.get(\"questions\"));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t_attachSharedEvents: function(isAttach) {\r\n\r\n\t\t\t\t// add/remove api for controlling engine\r\n\t\t\t\tvar commandAPI = [\"show\", \"setSubmitted\", \"setShowAnswer\", \"setInstructionBtnCaption\", \"save\",\r\n\t\t\t\t\t\t\t\t\t\"engineShow\", \"engineHide\"];\r\n\t\t\t\t_.each(commandAPI, function(name) {\r\n\t\t\t\t\tvar funcName = \"cmd\" + name.charAt(0).toUpperCase() + name.slice(1);\r\n\t\t\t\t\tif (isAttach) {\r\n\t\t\t\t\t\tthis.sharedEvents.on(\"engine:cmd:\" + name, _.bind(this[funcName], this));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.sharedEvents.off(\"engine:cmd:\" + name, _.bind(this[funcName], this));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tif (isAttach) {\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").on(\"change:complete\", _.bind(this.sendCompleteChange, this));\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").on(\"change:correct\", _.bind(this.sendCorrectChange, this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").off(\"change:complete\", _.bind(this.sendCompleteChange, this));\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").off(\"change:correct\", _.bind(this.sendCorrectChange, this));\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.EmbeddedContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.EmbeddedContext.constructor = App.Shell.EmbeddedContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;/**\r\n * Created by sgumar on 22-02-2017.\r\n */\r\n(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running on SCORM\r\n\t */\r\n\r\n\tApp.Shell.ScormContext = function() {\r\n\r\n\t\tconsole.log(\"create SCORM context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\" ? true : undefined;\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine as a popup (e.g glossary) it needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"floe\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisFloe: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\toriginalEngineClass: this.getEngineClass(engineID),\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tstateEditor: new App.Model.StateEditorModel(),\r\n\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\tisPresentationMode: false,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tif ($.getQueryString(\"alertErrors\") === \"true\") {\r\n\t\t\t\t\t// could be useful in some situations\r\n\t\t\t\t\twindow.onerror = function(msg, url, linenumber) {\r\n\t\t\t\t\t\talert(\"Error message: \" + msg + \"\\nURL: \" + url + \"\\nLine Number: \" + linenumber);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Smooth scrolling hack for phonegap app\r\n\t\t\t\tdocument.addEventListener(\"touchstart\", function() {}, false);\r\n\r\n\t\t\t\t$(document).keydown(_.bind(function(e) {\r\n\t\t\t\t\tif ((e.keyCode === 119) && e.ctrlKey && e.shiftKey) { // ctrl + shift + F8\r\n\t\t\t\t\t\tconsole.log(\"engine state:\");\r\n\t\t\t\t\t\tvar resultsState = this.engineModel.getResultsState();\r\n\t\t\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\t\t\tconsole.log(encodeURIComponent(JSON.stringify(resultsState.results)));\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t\t$(document).click(_.bind(function(e) {\r\n\t\t\t\t\tif (window.parent.$) {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-click\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\t//window.getData();\r\n\t\t\t\tvar state = window.getData();\r\n\t\t\t\tif (state) {\r\n\t\t\t\t\tif (state.isSubmit) {\r\n\t\t\t\t\t\tlocalStorage.clear();\r\n\t\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\t\tvar message = \"You started this activity, but you did not finish.<br />Do you want to <b>Continue</b> this activity or <b>Start Again</b>?\";\r\n\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\t\ttext: message,\r\n\t\t\t\t\t\t\tbutton1: \"Continue\",\r\n\t\t\t\t\t\t\tbutton2: \"Start Again\"\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\tconsole.log(this.commonUIModel.get(\"messageResult\"));\r\n\t\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\t\tconsole.log(\"resume\");\r\n\t\t\t\t\t\t\t\tthis.resultsState = {\r\n\t\t\t\t\t\t\t\t\tresults: state.resultsState.results\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t\t\t} else if (this.commonUIModel.get(\"messageResult\") === 1) {\r\n\t\t\t\t\t\t\t\tlocalStorage.clear();\r\n\t\t\t\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t\tonLoaded();\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"load\");\r\n\t\t\t\tconsole.dir(this.resultsState);\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tconsole.log(\"save submitted=\" + isSubmit);\r\n\t\t\t\t//console.dir(resultsState);\r\n\t\t\t\tvar resultData = resultsState.results;\r\n\t\t\t\tvar resultDataLength = resultData.length;\r\n\t\t\t\tvar score = null;\r\n\t\t\t\tif (engineID === \"H_26_SEQ\" || engineID === \"H_5_HGLT\" || engineID === \"H_27_PFRD\"  || engineID === \"H_31_PLCTST\" || engineID === \"H_44_PLCTSTMTE\" || (engineID === \"H_6_FIBMS\" && resultData.length === 1)) {\r\n\t\t\t\t\tscore = resultData[0].score;\r\n\t\t\t\t} else if (engineID === \"H_22_FIBAU\" || engineID === \"H_18_FIBDD\" || engineID === \"H_12_SORT\") {\r\n\t\t\t\t\tscore = 0;\r\n\t\t\t\t\tresultDataLength = 0;\r\n\t\t\t\t\tfor (var resultone in resultData) {\r\n\t\t\t\t\t\tif (resultone) {\r\n\t\t\t\t\t\t\tscore += resultData[resultone].score;\r\n\t\t\t\t\t\t\tresultDataLength += resultData[resultone].possible;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var result in resultData) {\r\n\t\t\t\t\t\tif (resultData[result].score > 0) {\r\n\t\t\t\t\t\t\tscore = score + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (engineID === \"H_26_SEQ\" || engineID === \"H_5_HGLT\" || engineID === \"H_27_PFRD\"  || engineID === \"H_31_PLCTST\" || engineID === \"H_44_PLCTSTMTE\" || (engineID === \"H_6_FIBMS\" && resultData.length === 1)) {\r\n\t\t\t\t\tresultDataLength = resultData[0].possible;\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.isStandalone) {\r\n\t\t\t\t\tvar data = {\r\n\t\t\t\t\t\tresultsState: resultsState,\r\n\t\t\t\t\t\tdate: new Date(),\r\n\t\t\t\t\t\tisSubmit: isSubmit,\r\n\t\t\t\t\t\tscore: score,\r\n\t\t\t\t\t\tmaxScore: resultDataLength\r\n\t\t\t\t\t};\r\n\t\t\t\t\twindow.postData(data);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if this is being used in an iframe the parent might use this data\r\n\t\t\t\t// (e.g. the engine are running on a cd-rom wrapper)\r\n\t\t\t\tif (window.parent.$) {\r\n\t\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-submit\", resultsState);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-soft-save\", resultsState);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this simulates a slight backend lag before the submit completes\r\n\t\t\t\t_.delay(_.bind(function() {\r\n\t\t\t\t\tthis.engineModel.saveSuccessful(isSubmit);\r\n\t\t\t\t}, this), isSubmit ? 2000 : 100);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\t// the external settings file has loaded. Floe mode can have a 'clean'\r\n\t\t\t\t// standalone mode where things like version and state viewer are suppressed\r\n\t\t\t\tif (this.isStandalone === undefined) {\r\n\t\t\t\t\tthis.isStandalone = this.readConfigSetting(\"settings.isStandalone\", false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.ScormContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.ScormContext.constructor = App.Shell.ScormContext;\r\n\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\tApp.Model.StateEditorItemModel = Backbone.Model.extend({\r\n\r\n\t\t/*\r\n\t\t * defaults holds default attribute values.\r\n\t\t * These aren't validated, so make sure they are correct.\r\n\t\t */\r\n\t\tdefaults: {\r\n\t\t\tresultsState: null,\t// an engine state object\r\n\t\t\tdate: null,\t\t\t// time save occured\r\n\t\t\tisSubmit: false\t\t// soft save or final save?\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * initialize() is invoked when an instance of this model is created\r\n\t\t */\r\n\t\tinitialize: function() {\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Public Methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Private methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Event Handlers\r\n\t\t */\r\n\r\n\r\n\r\n\t});\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\tApp.Model.StateEditorModel = Backbone.Model.extend({\r\n\r\n\t\t/*\r\n\t\t * defaults holds default attribute values.\r\n\t\t * These aren't validated, so make sure they are correct.\r\n\t\t */\r\n\t\tdefaults: {\r\n\t\t\tstateSaves: new Backbone.Collection(),\t// a list or state saves made by the engine\r\n\t\t\titemIndex: -1,\t\t\t\t\t\t\t// the current save the editor is inspecting\r\n\t\t\tviewType: 2\t\t\t\t\t\t\t\t// 0 raw 1 rawmyelt 2 myeltgradebook\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * initialize() is invoked when an instance of this model is created\r\n\t\t */\r\n\t\tinitialize: function() {\r\n\r\n\t\t\tthis.get(\"stateSaves\").model = App.Model.StateEditorItemModel;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Public Methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Private methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Event Handlers\r\n\t\t */\r\n\r\n\r\n\r\n\t});\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * use querry &console=true to enable the inline console. Meant really for bookshelf client debugging\r\n\t * but perhaps useful for light debugging of ipads on PC without getting a Mac fired up\r\n\t */\r\n\r\n\r\n\tApp.View.ConsoleView = Backbone.View.extend({\r\n\r\n\t\toldLog: null,\r\n\t\toldError: null,\r\n\t\toldDir: null,\r\n\t\tlastLog: undefined,\r\n\t\tlastCount: 0,\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"console init\");\r\n\r\n\t\t\tif (window.console.log) {\r\n\t\t\t\tthis.oldLog = window.console.log;\r\n\t\t\t}\r\n\r\n\t\t\tif (window.console.dir) {\r\n\t\t\t\tthis.oldDir = window.console.dir;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (window.onerror) {\r\n\t\t\t\tthis.oldError = window.onerror;\r\n\t\t\t}\r\n\r\n\t\t\twindow.console.log = _.bind(this.log, this);\r\n\t\t\twindow.console.dir = _.bind(this.dir, this);\r\n\t\t\twindow.onerror = _.bind(this.error, this);\r\n\r\n\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tvar layout = \"<div class='inline-console'><div class='title-btn'>Console</div><div class='content-txt-holder'><div class='content-txt'></div></div></div>\";\r\n\t\t\tthis.setElement($(layout));\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.toggleClass(\"expanded\");\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\tlog: function(s) {\r\n\r\n\t\t\tthis.logStr(s);\r\n\r\n\t\t\tif (this.oldLog) {\r\n\t\t\t\tthis.oldLog.call(console, s);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tdir: function(obj) {\r\n\r\n\t\t\tthis.logStr(JSON.stringify(obj)); // better than nothing\r\n\r\n\t\t\tif (this.oldDir) {\r\n\t\t\t\tthis.oldDir.call(console, obj);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\terror: function(errorMsg, url, lineNumber) {\r\n\r\n\t\t\tif (!this.$(\".content-txt\").length) {\r\n\t\t\t\treturn; // not active yet\r\n\t\t\t}\r\n\r\n\t\t\tthis.$(\".content-txt\").append(\"<p class='error'>\" + errorMsg + \" \" + url + \" \" + lineNumber + \"</p>\");\r\n\t\t\tif (this.oldError) {\r\n\t\t\t\tthis.oldError(errorMsg, url, lineNumber);\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToBottom();\r\n\t\t},\r\n\r\n\t\tscrollToBottom: function() {\r\n\r\n\t\t\tthis.$(\".content-txt\").scrollTop(this.$(\".content-txt\").get(0).scrollHeight);\r\n\r\n\t\t},\r\n\r\n\t\tescapeString: function(s) {\r\n\r\n\t\t\ts = String(s).replace(/&/gi, \"&amp;\");\r\n\t\t\ts = s.replace(/</gi, \"&lt;\");\r\n\t\t\ts = s.replace(/>/gi, \"&gt;\");\r\n\t\t\ts = s.replace(/\"/gi, \"&quot;\");\r\n\t\t\ts = s.replace(/'/gi, \"&apos;\");\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\tlogStr: function(s) {\r\n\r\n\t\t\tif (!this.$(\".content-txt\").length) {\r\n\t\t\t\treturn; // not active yet\r\n\t\t\t}\r\n\r\n\t\t\ts = this.escapeString(s);\r\n\r\n\t\t\tif ((this.lastLog === undefined) || this.lastLog !== s) {\r\n\t\t\t\tthis.lastLog = s;\r\n\t\t\t\tthis.lastCount = 1;\r\n\t\t\t} else {\r\n\t\t\t\tthis.lastCount++;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.lastCount > 1) {\r\n\t\t\t\tthis.$(\".content-txt p\").last().replaceWith(\"<p>\" + this.lastLog + \" <span class='count'>\" + this.lastCount + \"</span></p>\");\r\n\t\t\t} else {\r\n\t\t\t\tthis.$(\".content-txt\").append(\"<p>\" + s + \"</p>\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToBottom();\r\n\t\t}\r\n\r\n\t});\r\n}());\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * this tool is used on floe and during develpoment for testing state load and save\r\n\t */\r\n\r\n\r\n\tApp.View.StateEditorView = Backbone.View.extend({\r\n\r\n\t\t_model: null,\r\n\t\t_myeltContext: null,\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"state editor init\");\r\n\t\t\tthis._model = options.model;\r\n\t\t\tthis.listenTo(this._model, \"change:itemIndex\", this.renderList);\r\n\t\t\tthis.listenTo(this._model, \"change:viewType\", this.renderList);\r\n\r\n\t\t\tthis.template = this.getTemplate(\"#common-ui-state-editor\");\r\n\r\n\t\t\tconsole.log(\"create MyEltContext for state preview\");\r\n\t\t\tthis._myeltContext = new App.Shell.MyEltContext();\r\n\r\n\t\t\t$(window).resize(_.bind(this._handleResize, this));\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\",\r\n\t\t\t\"click .preview-btn\": \"_previewBtnClick\",\r\n\t\t\t\"click .previous-btn:not(disabled)\": \"_previousBtnClick\",\r\n\t\t\t\"click .next-btn:not(disabled)\": \"_nextBtnClick\",\r\n\t\t\t\"change .dataview\": \"_dataViewChange\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tthis.setElement($(this.template));\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\trenderList: function() {\r\n\r\n\t\t\tvar stateSaves = this._model.get(\"stateSaves\");\r\n\t\t\tvar itemIndex = this._model.get(\"itemIndex\");\r\n\t\t\tvar viewType = this._model.get(\"viewType\");\r\n\t\t\tvar stateRecord = stateSaves.at(itemIndex); // StateEditorItemModel\r\n\t\t\tvar resultsState = stateRecord.get(\"resultsState\");\r\n\r\n\t\t\tthis.$(\".previous-btn\").prop(\"disabled\", itemIndex === 0);\r\n\t\t\tthis.$(\".next-btn\").prop(\"disabled\", itemIndex === stateSaves.length - 1);\r\n\r\n\t\t\tvar info = (this._model.get(\"itemIndex\") + 1) + \"\\xA0of\\xA0\" + stateSaves.length;\r\n\t\t\tvar date = stateRecord.get(\"date\");\r\n\t\t\tvar ms = date.getMilliseconds().toString();\r\n\t\t\tms = String(\"000\").substr(0, 3 - ms.length) + ms;\r\n\t\t\tinfo += \" (\" +  date.toTimeString().substring(0, 8) + \".\" + ms + \") \";\r\n\t\t\tinfo += stateRecord.get(\"isSubmit\") ? \"submitted\" : \"soft\";\r\n\t\t\tthis.$(\".info-txt\").text(info);\r\n\t\t\tthis.$(\".title-btn\").css(\"display\", stateSaves.length ? \"block\" : \"none\");\r\n\t\t\tthis.$(\".title-btn\").text(\"Saves\" + \" \" + stateSaves.length);\r\n\r\n\t\t\tvar myeltResponse = this._myeltContext.packResults(resultsState).response;\r\n\r\n\t\t\tthis.$(\".content-txt\").empty();\r\n\r\n\t\t\tif (viewType === 0) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeRawContent(resultsState));\r\n\t\t\t} else if (viewType === 1) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeRawMyEltContent(myeltResponse));\r\n\t\t\t} else if (viewType === 2) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeMyEltGradebookContent(myeltResponse));\r\n\t\t\t}\r\n\r\n\t\t\tthis.$(\".content-txt .question\").click(function() {\r\n\t\t\t\tvar $question = $(this);\r\n\t\t\t\t$question.toggleClass(\"expanded\");\r\n\t\t\t});\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.add($(\"#content\")).toggleClass(\"pushleft-tool-expanded\");\r\n\t\t\t$(window).trigger(\"resize\");\r\n\t\t},\r\n\r\n\t\t_previewBtnClick: function(e) {\r\n\r\n\t\t\tvar stateSaves = this._model.get(\"stateSaves\");\r\n\t\t\tvar itemIndex = this._model.get(\"itemIndex\");\r\n\t\t\tvar stateRecord = stateSaves.at(itemIndex);\r\n\t\t\tvar resultsState = stateRecord.get(\"resultsState\");\r\n\t\t\tvar stateData = encodeURIComponent(JSON.stringify(resultsState.results));\r\n\t\t\tvar url = document.URL;\r\n\t\t\tif (this.context.commonUIModel.get(\"submitted\")) {\r\n\t\t\t\turl += \"&preview=true\";\r\n\t\t\t}\r\n\t\t\turl += \"&resultsState=\" + stateData;\r\n\t\t\twindow.open(url);\r\n\r\n\t\t},\r\n\r\n\t\t_previousBtnClick: function(e) {\r\n\t\t\tthis._model.set(\"itemIndex\", this._model.get(\"itemIndex\") - 1);\r\n\t\t},\r\n\r\n\t\t_nextBtnClick: function(e) {\r\n\t\t\tthis._model.set(\"itemIndex\", this._model.get(\"itemIndex\") + 1);\r\n\t\t},\r\n\r\n\t\t_dataViewChange: function(e) {\r\n\t\t\tthis._model.set(\"viewType\", $(e.currentTarget).get(0).selectedIndex);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_makeRawContent: function(resultsState) {\r\n\r\n\t\t\treturn $(\"<pre />\").addClass(\"raw\").text(JSON.stringify(resultsState, undefined, 2));\r\n\t\t},\r\n\r\n\t\t_makeRawMyEltContent: function(myeltResponse) {\r\n\r\n\t\t\treturn $(\"<pre />\").addClass(\"rawMyElt\").text(JSON.stringify(myeltResponse, undefined, 2));\r\n\t\t},\r\n\r\n\t\t_makeMyEltGradebookContent: function(myeltResponse) {\r\n\r\n\t\t\tvar template = _.template(this.getTemplate(\"#common-ui-state-gradebook-template\"));\r\n\t\t\treturn template(myeltResponse);\r\n\t\t},\r\n\r\n\t\t_handleResize: function() {\r\n\t\t\tthis.$(\".content-txt-holder\").height(this.$el.height() - this.$(\".controls\").height());\r\n\t\t\tthis.$(\".content-txt-holder\").css(\"padding-top\", this.$(\".controls\").height());\r\n\t\t}\r\n\r\n\r\n\r\n\t});\r\n}());\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * use querry &console=true to enable the inline console. Meant really for bookshelf client debugging\r\n\t * but perhaps useful for light debugging of ipads on PC without getting a Mac fired up\r\n\t */\r\n\r\n\r\n\tApp.View.ThemeEditorView = Backbone.View.extend({\r\n\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"theme editor init\");\r\n\r\n\t\t\t_.bindAll(this, \"_dumpTheme\");\r\n\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\",\r\n\t\t\t\"change input\": \"_inputChange\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tvar layout = \"<div class='theme-editor'><div class='title-btn'>Theme Editor</div><div class='content-txt-holder'><div class='content-txt'></div></div></div>\";\r\n\t\t\tthis.setElement($(layout));\r\n\r\n\t\t\tvar content = \"<table>\";\r\n\t\t\tfor (var p in this.context.theme) {\r\n\t\t\t\tif (this.context.theme.hasOwnProperty(p)) {\r\n\t\t\t\t\tcontent += \"<tr>\";\r\n\t\t\t\t\tcontent += \"<td>\" + p + \"</td>\" +  \"<td><input type=\\\"color\\\" name=\\\"\" + p + \"\\\"\" + \" value=\\\"\" + this.context.theme[p] + \"\\\"/></td>\";\r\n\t\t\t\t\tcontent += \"</tr>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcontent += \"</table>\";\r\n\t\t\tcontent += \"<p>Copy the content below and paste it into your config file.</p>\";\r\n\r\n\t\t\tcontent += \"<pre class=\\\"output\\\"></pre>\";\r\n\r\n\t\t\tthis.$(\".content-txt\").append(content);\r\n\r\n\t\t\tthis._dumpTheme();\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.toggleClass(\"expanded\");\r\n\r\n\t\t},\r\n\r\n\t\t_inputChange: function(e) {\r\n\r\n\t\t\tvar $input = $(e.currentTarget);\r\n\t\t\tvar name = $input.attr(\"name\");\r\n\t\t\tvar value = $input.val();\r\n\t\t\tthis.trigger(\"themeChange\", name, value);\r\n\r\n\t\t\tthis._dumpTheme();\r\n\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_dumpTheme: function() {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tthemes: {\r\n\t\t\t\t\tdefaultTheme: {\r\n\t\t\t\t\t\tvalues: this.context.theme\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tthis.$(\".output\").text(JSON.stringify(data, undefined, 2));\r\n\t\t}\r\n\r\n\r\n\t});\r\n}());\r\n\r\n","fileId":"f1","on":true},{"type":"fileOverride","match":"https://myelt.heinle.com/media/books/*/shell/*/shell.js","file":"/* cengage-html-engines v1.0.43 Shell v1.0.43 UTC 2016-06-09 14:09:07 */\r\n\r\nvar App = (function() {\r\n\r\n\t\"use strict\";\r\n\r\n\tfunction init() {\r\n\r\n\t\tApp.Shell.create();\r\n\t}\r\n\r\n\treturn {\r\n\t\tShell: {},\r\n\t\tModel: {},\r\n\t\tView: {},\r\n\t\tCollection: {},\r\n\t\tUtils: {},\r\n\t\tinit: init\r\n\t};\r\n\r\n}());\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\tApp.Shell.create = function() {\r\n\r\n\t\tvar loader;\r\n\t\tvar context;\r\n\t\tvar assets;\r\n\t\tvar requisites;\r\n\t\tvar engineModel;\r\n\t\tvar commonUIModel;\r\n\t\tvar consoleView;\r\n\t\tvar themeEditorView;\r\n\t\tvar stateEditorView;\r\n\r\n\t\tfunction init() {\r\n\r\n\t\t\tconsole.log(\"cengage engine shell init\");\r\n\r\n\t\t\t// Remove 300ms delay from click events on touch devices.\r\n\t\t\tFastClick.attach(document.body);\r\n\r\n\t\t\t// find application context\r\n\t\t\tif ($.getQueryString(\"embeddedID\") !== undefined) {\r\n\t\t\t\t// engine embedded inside another engine (e.g. progress test)\r\n\t\t\t\tcontext = new App.Shell.EmbeddedContext();\r\n\t\t\t} else if ($.getQueryString(\"did\") !== undefined) {\r\n\t\t\t\t// floe mode\r\n\t\t\t\tcontext = new App.Shell.FloeContext();\r\n\t\t\t} else if ($.getQueryString(\"activity\") !== undefined) {\r\n\t\t\t\t// bookshelf mode\r\n\t\t\t\tcontext = new App.Shell.BookshelfContext();\r\n\t\t\t} else {\r\n\t\t\t\t// myelt mode\r\n\t\t\t\tcontext = new App.Shell.MyEltContext();\r\n\t\t\t}\r\n\r\n\t\t\tcontext.init(function() {\r\n\r\n\t\t\t\tconsole.log(\"shell gets application context initialized\");\r\n\r\n\t\t\t\tloadAssets();\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadAssets() {\r\n\r\n\t\t\t// load inert assets such as configs and layouts\r\n\r\n\t\t\tcontext.log(\"load assets\");\r\n\t\t\tvar engineLayout = context.engineLayout;\r\n\t\t\tvar commonUILayout = engineLayout.substring(0, engineLayout.lastIndexOf(\"/\")) + \"/common-ui.html\";\r\n\t\t\tvar productDataPath = context.dataPath;\r\n\t\t\tif (context.productConfigDataPathOverride) {\r\n\t\t\t\t// a potential override (e.g. in the case of basebook usage)\r\n\t\t\t\tproductDataPath = context.productConfigDataPathOverride;\r\n\t\t\t}\r\n\r\n\t\t\tassets = {}; // will store loaded assets\r\n\r\n\t\t\tvar assetsList = [\r\n\t\t\t\t{\r\n\t\t\t\t\t// global application configuration\r\n\t\t\t\t\tid: \"config\",\r\n\t\t\t\t\turl: context.dataPath + \"config.json\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// application configuration specific to a particular product\r\n\t\t\t\t\tid: \"configProduct\",\r\n\t\t\t\t\turl: productDataPath + \"config\" + \"_\" + context.productType.toLowerCase() + \".json\",\r\n\t\t\t\t\toptional: true\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// jwplayer skin\r\n\t\t\t\t\tid: \"jwplayerSkin\",\r\n\t\t\t\t\turl: context.dataPath + \"myelt_media_skin.xml\",\r\n\t\t\t\t\tsettings: {\r\n\t\t\t\t\t\tdataType: \"text\"\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// myelt theme css template\r\n\t\t\t\t\tid: \"myeltTheme\",\r\n\t\t\t\t\turl: context.dataPath + \"myelt_theme.txt\"\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// html for common UI\r\n\t\t\t\t\tid: \"commonUILayout\",\r\n\t\t\t\t\turl: commonUILayout\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// html for engine UI\r\n\t\t\t\t\tid: \"engineLayout\",\r\n\t\t\t\t\turl: engineLayout\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\t// activity XML\r\n\t\t\t\t\tid: \"activityData\",\r\n\t\t\t\t\turl: context.activity + (context.isFloe ? \"?nocache=\" + (new Date().getTime()) : \"\"),\r\n\t\t\t\t\tsettings: {\r\n\t\t\t\t\t\tdataType: \"text\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t];\r\n\r\n\t\t\tloader = new App.Utils.AssetLoader(assetsList, buildConfig);\r\n\r\n\t\t}\r\n\r\n\t\tfunction buildConfig() {\r\n\r\n\t\t\tassets = loader.assets;\r\n            // note config settings can lever context properties via templates\r\n\t\t\t// and also how the base config is merged with a potential per product config\r\n\r\n\t\t\tcontext.config = $.extend(true, processConfig(assets.config), processConfig(assets.configProduct));\r\n\r\n\t\t\tvar useMediaFromProduct = context.readConfigSetting(\"media.useMediaFromProduct\");\r\n\t\t\tif ($.getQueryString(\"useMediaFromProduct\")) {\r\n\t\t\t\tuseMediaFromProduct = $.getQueryString(\"useMediaFromProduct\");\r\n\t\t\t}\r\n\t\t\t// here we can redirect a product to use the media from a different product\r\n\t\t\tif (useMediaFromProduct) {\r\n\t\t\t\tcontext.changeProductMedia(useMediaFromProduct);\r\n\t\t\t}\r\n\r\n\t\t\tcontext.processConfig(); // a chance for context to do something with config\r\n\r\n\t\t\tloadLocale();\r\n\r\n\t\t}\r\n\r\n\t\tfunction loadLocale() {\r\n\r\n\t\t\t// a way of adding translated text into the engines\r\n\t\t\t// currently this support is lightly used so the implementation is basic\r\n\r\n\t\t\tvar locale = context.readConfigSetting(context.engineClass.toLowerCase() + \".localization.lang\", \"\");\r\n\t\t\tif (!locale) {\r\n\t\t\t\tlocale = context.readConfigSetting(\"localization.lang\", \"en\");\r\n\t\t\t}\r\n\t\t\tif ($.getQueryString(\"locale\")) {\r\n\t\t\t\tlocale = $.getQueryString(\"locale\");\r\n\t\t\t}\r\n\t\t\tcontext.locale = locale;\r\n\r\n\t\t\tif (locale !== \"en\") {\r\n\t\t\t\tvar localizedAssetsList = [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: \"localizedCommonUILayout\",\r\n\t\t\t\t\t\turl: context.commonUILayout\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: \"localizedEngineLayout\",\r\n\t\t\t\t\t\turl: context.engineLayout\r\n\t\t\t\t\t}\r\n\t\t\t\t];\r\n\t\t\t\t_.each(localizedAssetsList, function(asset, index) {\r\n\r\n\t\t\t\t\tvar parts = asset.url.split(\"/\");\r\n\t\t\t\t\tparts.splice(parts.length - 1, 0, \"locales\", locale);\r\n\t\t\t\t\tvar localizedLayoutPath = parts.join(\"/\");\r\n\t\t\t\t\tasset.url = localizedLayoutPath;\r\n\t\t\t\t\tasset.optional = true;\r\n\t\t\t\t});\r\n\t\t\t\tvar localeLoader = new App.Utils.AssetLoader(localizedAssetsList, function() {\r\n\t\t\t\t\t$.extend(assets, localeLoader.assets);\r\n\t\t\t\t\tloadEngine();\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tloadEngine();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction loadEngine() {\r\n\r\n\t\t\tif (context.readConfigSetting(\"settings.queryString.console\") === true) {\r\n\t\t\t\t// optional inline console can also be activated via config rather than query string\r\n\t\t\t\tshowInlineConsole();\r\n\t\t\t}\r\n\r\n\t\t\trequisites = [];\r\n\r\n\t\t\tif (App.Model[context.engineClass + \"Model\"] === undefined) {\r\n\r\n\t\t\t\t// may have already loaded engine code (e.g. via a test index or minified engines lib)\r\n\t\t\t\t// in that case we can skip the dynamic engine load\r\n\r\n\t\t\t\tvar engineBase = context.engine.split(\"/\").slice(0, -2).join(\"/\") + \"/\";\r\n\r\n\t\t\t\t// TODO load any additional libraries for engine now, these\r\n\t\t\t\t// will be specified in config.json\r\n\r\n\t\t\t\trequisites = [\r\n\t\t\t\t\t\tcontext.isDebug ? context.engine : context.engine.split(\".\").slice(0, -1).join(\".\") + \".min.js\",\r\n\t\t\t\t\t\tengineBase + \"css/\" + context.engineClass.toLowerCase() + (context.isDebug ? \"\" : \".min\") +  \".css\"\r\n\t\t\t\t];\r\n\t\t\t}\r\n\r\n\t\t\tif (!context.isMyElt) {\r\n\t\t\t\t$(\"head link\").each(function(i, el) {\r\n\t\t\t\t\tvar $link = $(this);\r\n\t\t\t\t\tif ($link.attr(\"data-delayed\") === \"true\") {\r\n\t\t\t\t\t\tvar href = $link.attr(\"href\");\r\n\t\t\t\t\t\tif (_.last(href.split(\".\")) === \"css\") {\r\n\t\t\t\t\t\t\trequisites.push(context.basePath + href);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (typeof delayedCss !== \"undefined\" && delayedCss !== undefined && delayedCss.length > 0) {\r\n\t\t\t\t\tfor (var i = 0; i < delayedCss.length; i++) {\r\n\t\t\t\t\t\trequisites.push(delayedCss[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (requisites.length > 0) {\r\n\t\t\t\tModernizr.load({\r\n\t\t\t\t\tload: requisites,\r\n\t\t\t\t\tcomplete: function() {\r\n\t\t\t\t\t\tengineLoaded();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tengineLoaded();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction engineLoaded() {\r\n\r\n\t\t\treplaceJWPlayerSkin(); // load skin directly to avoid skin load issue in mac bookshelf client\r\n\r\n\t\t\t/*\r\n\t\t\t * a liberty but jwplayer subtitle api did not allow this, we do not want to remember\r\n\t\t\t * subtitle on/off state between engines but do want to remember them within the engine\r\n\t\t\t */\r\n\t\t\tjwplayer.utils.saveCookie(\"captionLabel\", \"Off\");\r\n\r\n\t\t\tif (context.isMyElt) {\r\n\t\t\t\tif (typeof delayedCss !== \"undefined\" && delayedCss !== undefined && delayedCss.length > 0) {\r\n\t\t\t\t\tfor (var i = 0; i < delayedCss.length; i++) {\r\n\t\t\t\t\t\tvar index = i;\r\n\t\t\t\t\t\tcontext.adaptor.getCSSReMapUrls(delayedCss[i], function(delayedCssData) {\r\n\t\t\t\t\t\t// delayed sheets in myelt become inline so url paths need re-routing\r\n\t\t\t\t\t\tdelayedCssData = delayedCssData.replace(/\\.\\.\\//g, \"\");\r\n\t\t\t\t\t\tloadCssAsEmbedded(delayedCssData, \"vs-style-delayed-\" + index);\r\n\t\t\t\t\t\t// after the last delayed CSS is loaded, callback\r\n\t\t\t\t\t\tif (index === (delayedCss.length - 1)) {\r\n\t\t\t\t\t\t\tapplyTheme();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyTheme();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (context.isBookshelf) {\r\n\t\t\t\t\t// code injection by bookshelf can skew modernizer css insert point so fix it\r\n\t\t\t\t\t_.each(requisites, function(el) {\r\n\t\t\t\t\t\tvar $lastCss = $(\"head [rel=stylesheet]\").last();\r\n\t\t\t\t\t\tif (el.substr(el.lastIndexOf(\".\")) === \".css\") {\r\n\t\t\t\t\t\t\t$(\"head [href='\" + el + \"']\").insertAfter($lastCss);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tapplyTheme();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction applyTheme() {\r\n\r\n\t\t\t/*\r\n\t\t\t * This is applying the color values from the per book/product optional\r\n\t\t\t * config file into a css template which is appended to the document\r\n\t\t\t * the per book/product themes build on top of 'stock' themes\r\n\t\t\t */\r\n\r\n\t\t\tvar themeName = $.getQueryString(\"theme\");\r\n\t\t\tvar theme = context.readConfigSetting(\"themes.\" + (themeName ? themeName : \"defaultTheme\"));\r\n\t\t\tvar isStock = false;\r\n\t\t\tif (!theme) {\r\n\t\t\t\t// this is a stock theme\r\n\t\t\t\ttheme = context.readConfigSetting(\"themes.\" + context.gui);\r\n\t\t\t\tisStock = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (theme) {\r\n\t\t\t\tvar themes = [theme];\r\n\t\t\t\tif (!isStock && !theme.base) {\r\n\t\t\t\t\t// always build on top of stock to make sure all values are defined\r\n\t\t\t\t\ttheme.base = context.gui;\r\n\t\t\t\t}\r\n\t\t\t\tvar curTheme = theme;\r\n\t\t\t\twhile ((curTheme = context.readConfigSetting(\"themes.\" + curTheme.base))) {\r\n\t\t\t\t\tthemes.push(curTheme);\r\n\t\t\t\t}\r\n\t\t\t\tthemes.reverse();\r\n\t\t\t\ttheme = {\r\n\t\t\t\t\tvalues: {}\r\n\t\t\t\t};\r\n\t\t\t\tfor (var i = 0; i < themes.length; i++) {\r\n\t\t\t\t\t_.extend(theme.values, themes[i].values);\r\n\t\t\t\t}\r\n\t\t\t\tcontext.theme = theme.values;\r\n\t\t\t\tvar cssTheme = _.template(assets.myeltTheme, getThemeTemplateData());\r\n\t\t\t\tloadCssAsEmbedded(cssTheme, \"vs-inline-theme\");\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuildCommonUI();\r\n\t\t}\r\n\r\n\t\tfunction buildCommonUI() {\r\n\r\n\t\t\t// for flexibility styles can be passed via query string (e.g. popup glossary 'nochrome')\r\n\t\t\t// or from a config settings (e.g no-header)\r\n\t\t\tvar style = $.getQueryString(\"style\");\r\n\t\t\tvar configStyle = context.readConfigSetting(\"settings.style\", \"\");\r\n\t\t\tif (configStyle) {\r\n\t\t\t\tif (style) {\r\n\t\t\t\t\tstyle += \",\" + configStyle;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyle = configStyle;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (style) {\r\n\t\t\t\t_.each(style.split(\",\"), function(style) {\r\n\t\t\t\t\t$(\"#content\").addClass(style);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// setup shared glossary link system\r\n\r\n\t\t\tsetupGlossaryLinks();\r\n\r\n\t\t\t// setup shared word list link system\r\n\r\n\t\t\tsetupWordListLinks();\r\n\r\n\t\t\t// preprocess activity xml text (e.g. glossary links) and convert to xml object\r\n\r\n\t\t\tassets.activityData = $.parseXML(preprocessActivityData(assets.activityData));\r\n\r\n\t\t\t// template handling\r\n\r\n\t\t\tvar templates = assets.commonUILayout;\r\n\t\t\tif (assets.localizedCommonUILayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localizedCommonUILayout;\r\n\t\t\t}\r\n\t\t\ttemplates += \"\\n\" + assets.engineLayout;\r\n\t\t\tif (assets.localizedEngineLayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localizedEngineLayout;\r\n\t\t\t}\r\n\r\n\t\t\tif (assets.localeEngineLayout) {\r\n\t\t\t\ttemplates += \"\\n\" + assets.localeEngineLayout;\r\n\t\t\t}\r\n\r\n\t\t\tvar getTemplate = function(id, optional) {\r\n\t\t\t\tfunction _getTemplate(id, optional) {\r\n\t\t\t\t\tif (id.charAt(0) !== \"#\") {\r\n\t\t\t\t\t\tthrow(new Error(\"getTemplate function can only find templates by id\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tid = id.substring(1);\r\n\t\t\t\t\tvar regexp = new RegExp(\"<script type=\\\"text\\\\/template\\\" id=\\\"\" + id + \"\\\">[\\\\s\\\\S]*?<\\\\/script>\");\r\n\t\t\t\t\tvar matches = regexp.exec(templates);\r\n\t\t\t\t\tif (matches === null) {\r\n\t\t\t\t\t\tif (optional !== true) {\r\n\t\t\t\t\t\t\tthrow(new Error(\"Missing template with id \" + id));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar t = matches[0].replace(/<script.*>|<\\/script>/g, \"\");\r\n\t\t\t\t\tt = t.replace(/&nbsp;/gi, \"&#160;\"); // for xhtml\r\n\t\t\t\t\treturn t;\r\n\t\t\t\t}\r\n\t\t\t\tvar t;\r\n\t\t\t\tif (context.locale !== \"en\") {\r\n\t\t\t\t\t// if a localized version exists then use that\r\n\t\t\t\t\tt = _getTemplate(id + \"-\" + context.locale, true);\r\n\t\t\t\t}\r\n\t\t\t\tif (!t) {\r\n\t\t\t\t\tt = _getTemplate(id, optional);\r\n\t\t\t\t}\r\n\t\t\t\treturn t;\r\n\t\t\t};\r\n\r\n\t\t\t// allow easy access to context\r\n\t\t\tBackbone.Model.prototype.context = Backbone.View.prototype.context = context;\r\n\r\n\t\t\t// allow access to external text\r\n\t\t\tBackbone.Model.prototype.getTemplate = Backbone.View.prototype.getTemplate = getTemplate;\r\n\t\t\tBackbone.Collection.prototype.getTemplate = getTemplate;\r\n\r\n\t\t\t// add global events system\r\n\t\t\tBackbone.Model.prototype.appEvents = Backbone.View.prototype.appEvents = _.clone(Backbone.Events);\r\n\t\t\tBackbone.Model.prototype.getTemplate = getTemplate;\r\n\r\n\t\t\t// create inline theme editor if requested or by default in the special 'theme' preview engine\r\n\t\t\tif ($.getQueryString(\"theme-editor\") === \"true\" || context.engineClass === \"THEME\") {\r\n\t\t\t\tsetupThemeEditor();\r\n\t\t\t}\r\n\r\n\t\t\t// create state editor used for testing state load during development\r\n\t\t\tif ($.getQueryString(\"state-editor\") === \"true\" || context.isFloe) {\r\n\t\t\t\tsetupStateEditor();\r\n\t\t\t}\r\n\r\n\t\t\t// create common ui layer\r\n\t\t\tvar commonUITemplate = _.template(getTemplate(\"#common-ui-template\"));\r\n\r\n\t\t\tcommonUIModel = new App.Model.CommonUIModel();\r\n\r\n\t\t\tcommonUIModel.parseLayoutData(assets.activityData);\r\n            commonUIModel.parseConfigData(assets.config);      //parses config data to extract hasFlagEnabled attribute\r\n\r\n\t\t\t$(\"#content\").html(commonUITemplate(commonUIModel.toJSON()));\r\n\r\n\t\t\t// add control buttons for context type (optional per engine buttons can be added too)\r\n\t\t\tconsole.log(\"context.gui\" + context.gui);\r\n\t\t\tvar responseMode = $(assets.activityData).find(\"responseMode\").attr(\"value\");\r\n\t\t\tvar configResponseMode = context.readConfigSetting(\"settings.responseMode\");\r\n\t\t\tif (responseMode === configResponseMode) {\r\n\t\t\t\tcontext.gui = \"myelt-iwb\";\r\n\t\t\t\tcontext.isPresentationMode = true;\r\n\t\t\t}\r\n\t\t\tvar btnsID = \"#common-ui-\" + context.gui + (context.subgui ? \"-\" + context.subgui : \"\") + \"-btn-template\";\r\n\t\t\tvar btns = $(getTemplate(btnsID)).addClass(\"stock-btn\");\r\n\t\t\tvar customBtnsID = \"#\" + context.engineClass.toLowerCase() + \"-common-custom-buttons-template\";\r\n\t\t\tvar customBtns = $(getTemplate(customBtnsID, true)).addClass(\"custom-btn\");\r\n\t\t\tif (context.engineClass.toLowerCase() === \"concen\" || context.engineClass.toLowerCase() === \"tictac\" || context.engineClass.toLowerCase() === \"anskey\") {\r\n\t\t\t\t$(\"#content .control-btns\").append(customBtns);\r\n\t\t\t}else {\r\n\t\t\t\t$(\"#content .control-btns\").append(customBtns.add(btns));\r\n\t\t\t}\r\n\r\n\t\t\t//$(\"#content .control-btns\").append(customBtns.add(btns));\r\n\r\n\t\t\tvar commonUIView = new App.View.CommonUIView({\r\n\t\t\t\tmodel: commonUIModel\r\n\t\t\t});\r\n\t\t\tcommonUIModel.parseData(assets.activityData);\r\n\r\n\t\t\t// this makes ui visible in myelt, we need that to show \"load results?\" message\r\n\t\t\tcontext.initializationComplete();\r\n\r\n\t\t\tcontext.commonUIModel = commonUIModel;\r\n\r\n\t\t\t// note we need previous state before engine build\r\n\t\t\tcontext.load(contextLoaded);\r\n\r\n\t\t}\r\n\r\n\t\tfunction contextLoaded() {\r\n\r\n\t\t\tconsole.log(\"contextLoaded\");\r\n\r\n\t\t\tbuildEngine();\r\n\t\t}\r\n\r\n\r\n\t\tfunction buildEngine() {\r\n\r\n\t\t\t// allow gui variation based on context\r\n\t\t\t$(\"#content\").addClass(context.gui);\r\n\t\t\tif (context.subgui) {\r\n\t\t\t\t$(\"#content\").addClass(context.gui + \"-\" + context.subgui);\r\n\t\t\t}\r\n\r\n\t\t\t// scope some styles to low versions of IE so core styles (and QA) are not compromised\r\n\t\t\tvar vIE = App.Utils.getInternetExplorerVersion();\r\n\t\t\tif (vIE === 9 || vIE === 10) {\r\n\t\t\t\t$(\"#content\").addClass(\"IE\" + vIE);\r\n\t\t\t}\r\n\r\n\t\t\t// create engine layer\r\n\t\t\t$(\"#content\").addClass(context.engineClass.toLowerCase());\r\n\t\t\tvar engineClass = _.rest(context.engineID.split(\"_\"), 2).join().toUpperCase();\r\n\t\t\tengineModel = new App.Model[context.engineClass + \"Model\"]({}, {\r\n\t\t\t\tcommonUIModel: commonUIModel\r\n\t\t\t});\r\n\r\n\t\t\tcontext.setEngineModel(engineModel);\r\n\r\n\t\t\tvar engineView = new App.View[context.engineClass + \"View\"]({\r\n\t\t\t\tmodel: engineModel,\r\n\t\t\t\tel: \".engine\",\r\n\t\t\t\tcommonUIModel: commonUIModel\r\n\t\t\t});\r\n\t\t\tcommonUIModel.setEngine(engineModel);\r\n\r\n\t\t\tvar fontLoadStrategy = engineModel.getFontLoadStrategy();\r\n\t\t\tif (fontLoadStrategy.type === \"wait\") {\r\n\t\t\t\tvar fonts = [{name: \"lato\"}]; // TODO move to config\r\n\t\t\t\tvar fontLoadDetector = new App.Utils.FontLoadDetector($(\"body\"), fonts, function(status, item) {\r\n\t\t\t\t\tif (status !== \"font-load\") {\r\n\t\t\t\t\t\t// ignore individual font load events\r\n\t\t\t\t\t\t// wait for either all-fonts-loaded or an error, in any case just move on\r\n\t\t\t\t\t\tbuildActivity();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t} else {\r\n\t\t\t\tbuildActivity();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction buildActivity() {\r\n\r\n\t\t\tengineModel.parseData(assets.activityData, context);\r\n        }\r\n        /*\r\n\t\t * local shell utilities\r\n\t\t */\r\n\r\n\t\tfunction loadCssAsEmbedded(cssData, styleId) {\r\n\r\n\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\t\t\tvar style = document.createElement(\"style\");\r\n\t\t\tstyle.type = \"text/css\";\r\n\t\t\tstyle.id = styleId;\r\n\t\t\tif (style.styleSheet) {\r\n\t\t\t\tstyle.styleSheet.cssText = cssData;\r\n\t\t\t} else {\r\n\t\t\t\tstyle.appendChild(document.createTextNode(cssData));\r\n\t\t\t}\r\n\t\t\thead.appendChild(style);\r\n\t\t}\r\n\r\n\t\tfunction processConfig(configData) {\r\n\r\n\t\t\t// sometimes a string sometimes an object depending on server mime types\r\n\t\t\tvar config = typeof(configData) === \"object\" ? JSON.stringify(configData) : configData;\r\n\r\n\t\t\tif (config === \"\") {\r\n\t\t\t\tconfig = \"{}\"; // mac bookshelf client will not parse empty string\r\n\t\t\t}\r\n\r\n\t\t\t// config can use context properties in a macro like way\r\n\t\t\tconfig = JSON.parse(_.template(config, context));\r\n\t\t\treturn config;\r\n\t\t}\r\n\r\n\t\tfunction showInlineConsole() {\r\n\r\n\t\t\tif (!consoleView) {\r\n\t\t\t\tconsoleView = new App.View.ConsoleView();\r\n\t\t\t\t$(\"body\").append(consoleView.render().el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction replaceJWPlayerSkin() {\r\n\r\n\t\t\t/*\r\n\t\t\t * this is a workaround because jwplayer fails to load external skins in mac\r\n\t\t\t * bookshelf client. We do the load and then make it the jwplayer default skin.\r\n\t\t\t * This is not an exposed API so watch out for changes in jwplayer. Plus side is\r\n\t\t\t * that it is shared amongst multiple player instances so things are a little leaner\r\n\t\t\t */\r\n\r\n\t\t\tjwplayer.html5.defaultskin = function() {\r\n\t\t\t\tthis.text = assets.jwplayerSkin;\r\n\t\t\t\tthis.xml = jwplayer.utils.parseXML(this.text);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction preprocessActivityData(data) {\r\n\r\n\t\t\t// a chance to adjust activity data\r\n\t\t\t// replace flash glossary link format with html version\r\n\t\t\tdata = data.replace(/&lt;a +href=\"event:.*?&lt;\\/a&gt;/gi, function(match) {\r\n\t\t\t\tmatch = match.replace(\"target=\\\"_blank\\\"\", \"\");\r\n\t\t\t\tmatch = match.replace(/href=\"event:\\sglossary.*?\"/, function(match) {\r\n\t\t\t\t\tvar term = $.trim(_.rest(match.split(\",\"), 1).join().slice(0, -1));\r\n\t\t\t\t\treturn \"href=\\\"javascript:App.showGlossary('\" + term + \"')\\\"\";\r\n\t\t\t\t});\r\n\r\n\t\t\t\tmatch = match.replace(/href=\"event:\\s?wordlist.*?\"/, function(match) {\r\n\t\t\t\t\tvar splitMatch = match.replace(/\\\"/g, \"\").split(\",\");\r\n\t\t\t\t\tvar category = $.trim(splitMatch[1]);\r\n\t\t\t\t\tvar word =  $.trim(splitMatch[2]);\r\n\t\t\t\t\treturn \"href=\\\"javascript:App.showWordList('\" + category + \"' , '\" + word + \"')\\\"\";\r\n\t\t\t\t});\r\n\t\t\t\treturn match;\r\n\t\t\t});\r\n            // add global events system\r\n\t\t\tBackbone.Model.prototype.appEvents = Backbone.View.prototype.appEvents = _.clone(Backbone.Events);\r\n            commonUIModel = new App.Model.CommonUIModel();\r\n            commonUIModel.parseConfigData(assets.config);\r\n            if (!commonUIModel.get(\"hasFlashEnabled\")) {\r\n                data = data.replace(/mp3/g, \"ogg\");\r\n            }\r\n\t\t\treturn data;\r\n\t\t}\r\n\r\n\t\tfunction setupGlossaryLinks() {\r\n\t\t\tApp.showGlossary = function(term) {\r\n\t\t\t\t// vector global glossary popup links to commonUI\r\n\t\t\t\tBackbone.Model.prototype.appEvents.trigger(\"showGlossary\", term);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction setupWordListLinks() {\r\n\t\t\tApp.showWordList = function(category, word) {\r\n\t\t\t\t// global word list popup links to commonUI\r\n\t\t\t\tBackbone.Model.prototype.appEvents.trigger(\"showWordList\", category, word);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tfunction setupThemeEditor() {\r\n\t\t\tthemeEditorView = new App.View.ThemeEditorView();\r\n\t\t\t$(\"body\").append(themeEditorView.render().el);\r\n\t\t\tthemeEditorView.on(\"themeChange\", function(name, value) {\r\n\t\t\t\tcontext.theme[name] = value;\r\n\t\t\t\tvar cssTheme = _.template(assets.myeltTheme, getThemeTemplateData());\r\n\t\t\t\t$(\"#vs-inline-theme\").remove();\r\n\t\t\t\tloadCssAsEmbedded(cssTheme, \"vs-inline-theme\");\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction getThemeTemplateData() {\r\n\t\t\tvar themeData = _.clone(context.theme);\r\n\t\t\tthemeData.gui = \"\";\r\n\t\t\tif (context.gui !== \"myelt\") {\r\n\t\t\t\tthemeData.gui = \".\" + context.gui;\r\n\t\t\t\t// so we can scope the inline theme style with the gui root style\r\n\t\t\t\t// (e.g. .bookshelf .header ....) so inline does not become less specific\r\n\t\t\t}\r\n\t\t\treturn themeData;\r\n\t\t}\r\n\r\n\t\tfunction setupStateEditor() {\r\n\r\n\t\t\tstateEditorView = new App.View.StateEditorView({model: context.stateEditor});\r\n\t\t\t$(\"body\").append(stateEditorView.render().el);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * entry point\r\n\t\t */\r\n\r\n\t\tif ($.getQueryString(\"console\") === \"true\") {\r\n\t\t\t// optional inline console for debugging difficult containers such as bookshelf client apps\r\n\t\t\tshowInlineConsole();\r\n\t\t}\r\n\r\n\t\tinit();\r\n\r\n\t};\r\n\r\n}());\r\n\r\n\r\n\r\n\r\nApp.Shell.getVersion = function() { return \"shell-1.0.43\"; };\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This provides the shared functions between application contexts\r\n\t * An application context is an abstraction of the runtime environment\r\n\t * in which the shell and engines are situated\r\n\t */\r\n\r\n\tApp.Shell.Context = function() {\r\n\r\n\t};\r\n\r\n\t_.extend(App.Shell.Context.prototype, {\r\n\r\n\t\t\tgui: \"\",\r\n\t\t\tsubgui: \"\",\r\n\t\t\tsaveOnSubmit: true,\t\t\t\t\t\t// should we save state on submit / check answers\r\n\t\t\tstartupSubmitted: false,\t\t\t\t// loaded state tells engine to appear in \"submitted\" state\r\n\t\t\tengineModel: null,\t\t\t\t\t\t// the engine model set by shell when available\r\n\t\t\tcommonUIModel: null,\t\t\t\t\t// the commonUI model set by shell when available\r\n\t\t\tconfig: null,\t\t\t\t\t\t\t// config (app and per book settings files merged together) set by shell when loaded\r\n\t\t\tproductType: \"\",\t\t\t\t\t\t// first part of activity filename delimited by underscores i.e the book level e.g. PW3\r\n\t\t\ttheme: null,\t\t\t\t\t\t\t// series of colors as an object that are converted to css to \"theme\" a particular skin\r\n\t\t\tlocale: \"en\",\t\t\t\t\t\t\t// locale of interface\r\n\t\t\tsupportsWaitForCompletion: false,\t\t// engine save call completion notify event can be waited for\r\n\t\t\twaitForCompletionModalStyle: \"waiting\",\t// the modal style of the wait\r\n\r\n\r\n\t\t\tgetContextVersion: function() {\r\n\t\t\t\t// retrieve any version number associated with context the engine is situated\r\n\t\t\t\treturn \"\";\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\r\n\t\t\t\t// called when engine is fully ready, some contexts might do something here\r\n\t\t\t\tconsole.log(\"engineReady\");\r\n\t\t\t},\r\n\r\n\t\t\tsetEngineModel: function(engineModel) {\r\n\t\t\t\tthis.engineModel = engineModel;\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg) {\r\n\t\t\t\t// if context supports messages then send a message\r\n\t\t\t},\r\n\r\n\t\t\tcanReset: function() {\r\n\t\t\t\t// if the engine has reset, is it currently permitted\r\n\t\t\t\t// some contexts inhibit this depending on max tries etc\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\r\n\t\t\treset: function() {\r\n\t\t\t\t// the engine wants to reset, this is context specific\r\n\t\t\t\t// but the default is to reset the model\r\n\t\t\t\tthis.commonUIModel.reset();\r\n\t\t\t},\r\n\r\n\t\t\tgetEngineClass: function(engineID) {\r\n\t\t\t\tvar engineClass = _.rest(engineID.split(\"_\"), 2).join(); // lose production prefix (e.g. H_1_)\r\n\t\t\t\treturn engineClass;\r\n\t\t\t},\r\n\r\n\t\t\tremapEngineClass: function(engineClass) {\r\n\r\n\t\t\t\t// SNSC is basically the same as FIBMS, so the FIBMS code will support xml input from either type.\r\n\t\t\t\tif (engineClass === \"SNSC\") {\r\n\t\t\t\t\treturn \"FIBMS\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn engineClass;\r\n\t\t\t},\r\n\r\n\t\t\tremapEnginePath: function(engineClass, layout) {\r\n\r\n\t\t\t\t// SNSC is basically the same as FIBMS, so the FIBMS code will support xml input from either type.\r\n\t\t\t\tif (engineClass === \"SNSC\") {\r\n\t\t\t\t\tlayout = layout.replace(\"snsc\", \"fibms\");\r\n\t\t\t\t\tlayout = layout.replace(\"SNSC\", \"FIBMS\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn layout;\r\n\t\t\t},\r\n\r\n\t\t\tchangeProductMedia: function(newMediaProductType) {\r\n\t\t\t\t// we are product \"X\" but we want to use media from product \"Y\"\r\n\t\t\t\tthis.mediaPath = this.mediaPath.replace(this.productType, newMediaProductType);\r\n\t\t\t\tthis.makeMediaPaths();\r\n\t\t\t},\r\n\r\n\t\t\tstripResultsStateHtml: function(resultsState) {\r\n\t\t\t\t// gradebook wants plain text not rich text\r\n\t\t\t\tresultsState.common.directions = $.stripHtml(resultsState.common.directions);\r\n\t\t\t\t_.each(resultsState.results, function(result) {\r\n\t\t\t\t\tfor (var p in result) {\r\n\t\t\t\t\t\tif (_.isString(result[p]) && result[p].length) {\r\n\t\t\t\t\t\t\tresult[p] = $.stripHtml(result[p]);\r\n\t\t\t\t\t\t} else if (_.isArray(result[p])) {\r\n\t\t\t\t\t\t\t_.each(result[p], function(el, i) {\r\n\t\t\t\t\t\t\t\tif (_.isString(el) && el.length) {\r\n\t\t\t\t\t\t\t\t\tresult[p][i] = $.stripHtml(el);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tgetProductType: function(activity) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * the first part of the activity xml filename as delimited by an underscore provides\r\n\t\t\t\t * the product type and allows per product settings and skin colors\r\n\t\t\t\t * it also denotes the media subfolder to group related media assets for that product\r\n\t\t\t\t */\r\n\r\n\t\t\t\treturn _.first(_.last(activity.split(\"/\")).split(\"_\"));\r\n\t\t\t},\r\n\r\n\t\t\taddContextCommon: function() {\r\n\t\t\t\tthis.dataPath = this.basePath + \"data/\";\r\n\t\t\t\tthis.makeMediaPaths();\r\n\r\n\t\t\t\t// the bare filename part of the activity xml path\r\n\t\t\t\t// is sometimes used to encode data such as level\r\n\t\t\t\tthis.activityID = _.last(this.activity.split(\"/\")).split(\".\").shift();\r\n\r\n\t\t\t\t// html template common to all engines\r\n\t\t\t\tthis.commonUILayout = this.engineLayout.substring(0, this.engineLayout.lastIndexOf(\"/\")) + \"/common-ui.html\";\r\n\r\n\t\t\t},\r\n\r\n\t\t\tmakeMediaPaths: function() {\r\n\t\t\t\t_.forEach([\"image\", \"audio\", \"video\", \"pdf\"], function(el, i) {\r\n\t\t\t\t\tthis[el + \"Path\"] = this.mediaPath + el + \"/\";\r\n\t\t\t\t}, this);\r\n\t\t\t},\r\n\r\n\t\t\tgetMediaPath: function(rootType, mediaType) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * normally media is pathed into the product (per level) media folder\r\n\t\t\t\t * but there is a product common media (per product family) called contextCommon\r\n\t\t\t\t * and also a  system media folder that supports the user interface and is part of the UI\r\n\t\t\t\t * the former two are maintained by producers, the latter is for developers\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (rootType === \"system\") {\r\n\t\t\t\t\treturn this.basePath + \"media/\" + mediaType + \"/\";\r\n\t\t\t\t} else if (rootType === \"contentCommon\") {\r\n\t\t\t\t\treturn this.contentPath + \"media/common/\" + mediaType + \"/\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this[mediaType + \"Path\"];\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\t// the config has been attached, some contexts might do something with this call\r\n\r\n\t\t\t\tthis.subgui = this.readConfigSetting(\"appearance.interface.subgui\", this.subgui);\r\n\t\t\t},\r\n\r\n\t\t\treadConfigSetting: function(path, defaultVal) {\r\n\r\n\t\t\t\t// get setting from config file e.g. \"recording.sri.sri_product_id\"\r\n\r\n\t\t\t\treturn App.Utils.resolveNS(this.config, path, defaultVal);\r\n\t\t\t},\r\n\r\n\t\t\tgetFrameHeight: function(defaultHeight) {\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * allows context/LMS to influence engine height,\r\n\t\t\t\t * a default 'normal' height should be provided\r\n\t\t\t\t */\r\n\r\n\t\t\t\treturn defaultHeight;\r\n\t\t\t},\r\n\r\n\t\t\t// 'on mobile' flag\r\n\t\t\tisMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\r\n\r\n\t\t\t// isIOS flag\r\n\t\t\tisiOS: /iPhone|iPad|iPod/i.test(navigator.userAgent),\r\n\r\n\t\t\t//isAndroid flag\r\n\t\t\tisAndroid: /android/i.test(navigator.userAgent),\r\n\r\n\t\t\t// BookshelfDesktop detection\r\n\t\t\tisBookshelfDesktop: (function() {\r\n\t\t\t\tvar target = window.epubReadingSystem ? window.epubReadingSystem : parent.window.epubReadingSystem;\r\n\t\t\t\treturn target ? target.isDesktop() : false;\r\n\t\t\t})(),\r\n\r\n\t\t\tisIE9: (function() {\r\n\t\t\t\tif (navigator.appName.indexOf(\"Internet Explorer\") !== -1) {\r\n\t\t\t\t\tif (navigator.appVersion.indexOf(\"MSIE 9\") !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t})(),\r\n\r\n\t\t\t// isPC\r\n\t\t\tisPC: navigator.appVersion.indexOf(\"Win\") !== -1,\r\n\r\n\t\t\t// isMac\r\n\t\t\tisMac: navigator.platform.toUpperCase().indexOf(\"MAC\") !== -1,\r\n\r\n\t\t\tfeatures: {} // context specific hash revealing any special features\r\n\r\n\t\t});\r\n\r\n\r\n}());\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running on FLOE or locally\r\n\t */\r\n\r\n\tApp.Shell.FloeContext = function() {\r\n\r\n\t\tconsole.log(\"create FLOE context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\" ? true : undefined;\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine as a popup (e.g glossary) it needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"floe\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisFloe: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\toriginalEngineClass: this.getEngineClass(engineID),\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tstateEditor: new App.Model.StateEditorModel(),\r\n\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\tisPresentationMode: false,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tif ($.getQueryString(\"alertErrors\") === \"true\") {\r\n\t\t\t\t\t// could be useful in some situations\r\n\t\t\t\t\twindow.onerror = function(msg, url, linenumber) {\r\n\t\t\t\t\t\talert(\"Error message: \" + msg + \"\\nURL: \" + url + \"\\nLine Number: \" + linenumber);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Smooth scrolling hack for phonegap app\r\n\t\t\t\tdocument.addEventListener(\"touchstart\", function() {}, false);\r\n\r\n\t\t\t\t$(document).keydown(_.bind(function(e) {\r\n\t\t\t\t\tif ((e.keyCode === 119) && e.ctrlKey && e.shiftKey) { // ctrl + shift + F8\r\n\t\t\t\t\t\tconsole.log(\"engine state:\");\r\n\t\t\t\t\t\tvar resultsState = this.engineModel.getResultsState();\r\n\t\t\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\t\t\tconsole.log(encodeURIComponent(JSON.stringify(resultsState.results)));\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n                $(document).click(_.bind(function(e) {\r\n                    window.parent.$(\"iframe\").trigger(\"ngl-engine-click\");\r\n                }, this));\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\tvar state = $.getQueryString(\"resultsState\");\r\n\t\t\t\tif (_.isString(state) && (state.length > 0)) {\r\n\t\t\t\t\tthis.resultsState = {\r\n\t\t\t\t\t\tresults: JSON.parse(decodeURIComponent(state))\r\n\t\t\t\t\t};\r\n\t\t\t\t\tif ($.getQueryString(\"preview\") === \"true\") {\r\n\t\t\t\t\t\tthis.mode = \"state_preview\";\r\n\t\t\t\t\t\tthis.isPreview = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"load\");\r\n\t\t\t\tconsole.dir(this.resultsState);\r\n\t\t\t\tonLoaded();\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tconsole.log(\"save submitted=\" + isSubmit);\r\n\t\t\t\t//console.dir(resultsState);\r\n\r\n\t\t\t\tif (!this.isStandalone) {\r\n\t\t\t\t\tvar saves = this.stateEditor.get(\"stateSaves\");\r\n\t\t\t\t\tsaves.add(new App.Model.StateEditorModel({\r\n\t\t\t\t\t\tresultsState: resultsState,\r\n\t\t\t\t\t\tdate: new Date(),\r\n\t\t\t\t\t\tisSubmit: isSubmit\r\n\t\t\t\t\t}));\r\n\t\t\t\t\tthis.stateEditor.set(\"itemIndex\", saves.length - 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if this is being used in an iframe the parent might use this data\r\n\t\t\t\t// (e.g. the engine are running on a cd-rom wrapper)\r\n\t\t\t\tif (window.parent.$) {\r\n\t\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-submit\", resultsState);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twindow.parent.$(\"iframe\").trigger(\"ngl-engine-soft-save\", resultsState);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this simulates a slight backend lag before the submit completes\r\n\t\t\t\t_.delay(_.bind(function() {\r\n\t\t\t\t\tthis.engineModel.saveSuccessful(isSubmit);\r\n\t\t\t\t}, this), isSubmit ? 2000 : 100);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\t// the external settings file has loaded. Floe mode can have a 'clean'\r\n\t\t\t\t// standalone mode where things like version and state viewer are suppressed\r\n\t\t\t\tif (this.isStandalone === undefined) {\r\n\t\t\t\t\tthis.isStandalone = this.readConfigSetting(\"settings.isStandalone\", false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.FloeContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.FloeContext.constructor = App.Shell.FloeContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running in MyElt\r\n\t */\r\n\r\n\tApp.Shell.MyEltContext = function() {\r\n\r\n\t\tconsole.log(\"create MyElt context\");\r\n\r\n\t\tvar curTries = 0;\r\n\t\tvar MAX_RETRIES = 5; // TODO make dynamic\r\n\t\tvar SUBMIT = true;\r\n\t\tvar SOFTSAVE = false;\r\n\r\n\t\t_.extend(this, {\r\n\r\n\t\t\ttype: \"myelt\",\r\n\t\t\tgui: \"myelt\",\r\n\t\t\tisMyElt: true,\r\n\t\t\tadaptor: null,\r\n\t\t\tresultsState: null,\r\n\t\t\tinitCallback: null,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tthis.initCallback = initCallback;\r\n\r\n\t\t\t\t// Register with MyELT / Platform, and wait for it for the callback.\r\n\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"com.ilrn.activity.registerForReadyEvent\")) {\r\n\t\t\t\t\tthrow(new Error(\"MyELT LMS handler not available\"));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Register with MyELT / Platform, and wait for it for the callback.\r\n\t\t\t\tparent.com.ilrn.activity.registerForReadyEvent(_.bind(this._myEltReady, this));\r\n\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tthis.adaptor.debugLog(msg);\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tthis.log(\"engine reports initialization complete\");\r\n\t\t\t\t// TODO resize mode should be set in book xml rather than here\r\n\t\t\t\tthis.adaptor.initializationCompleted({\r\n\t\t\t\t\tRESIZE_MODE: \"fitHeightToWindow\",\r\n\t\t\t\t\tMIN_HEIGHT_THRESHOLD: \"580\"\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\tconsole.log(\"load state \" + this.mode.myeltState);\r\n\r\n\t\t\t\tif (this.mode.myeltState === \"state_resume\") {\r\n\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\tvar message = \"You started this activity, but you did not finish.<br />Do you want to <b>Continue</b> this activity or <b>Start Again</b>?\";\r\n\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\ttext: message,\r\n\t\t\t\t\t\tbutton1: \"Continue\",\r\n\t\t\t\t\t\tbutton2: \"Start Again\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t// continue last save\r\n\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\tthis.adaptor.getLastResults(_.bind(function(results, status) {\r\n\t\t\t\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\t\t\t\tthis.resultsState = this.unpackResults(results);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tonLoaded(); // start again\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t} else if (this.mode.myeltState === \"state_preview\") {\r\n\t\t\t\t\tthis.adaptor.getLastResults(_.bind(function(results, status) {\r\n\t\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\t\tthis.resultsState = this.unpackResults(results);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonLoaded();\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tonLoaded();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\t\t\t\tif (isSubmit) {\r\n\t\t\t\t\tthis.submitResults(resultsState);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.savePartialResults(resultsState);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\tApp.Shell.Context.prototype.processConfig.call(this);\r\n\r\n\t\t\t\tvar protstPassScorePerc = this.myeltParameterMap.myeltpassingpct;\r\n\t\t\t\tif (protstPassScorePerc !== undefined && protstPassScorePerc !== \"0\" && protstPassScorePerc !== 0) {\r\n\t\t\t\t\tApp.Utils.createNS(this.config, \"protst.passScorePerc\", protstPassScorePerc);\r\n\t\t\t\t}\r\n\t\t\t\tvar disableAnswers = this.myeltParameterMap.disableAnswers;\r\n\t\t\t\tif (disableAnswers !== undefined) {\r\n\t\t\t\t\tApp.Utils.createNS(this.config, \"settings.disableShowAnswers\", disableAnswers);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcanReset: function() {\r\n\t\t\t\t// if the engine has reset is it currently permitted\r\n\t\t\t\tif (this.myeltParameterMap.assignedMode === true) {\r\n\t\t\t\t\treturn this.myeltParameterMap.currentAttempt < this.myeltParameterMap.maxAttempts;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\treset: function() {\r\n\t\t\t\t// the engine wants to reset\r\n\r\n\t\t\t\t// this should reload the iframe in myelt\r\n\t\t\t\tthis.adaptor.retakeActivity(function(data, status) {\r\n\t\t\t\t\tif (status === \"ERROR\") {\r\n\t\t\t\t\t\tconsole.log(\"reset error\");\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tpackResults: function(resultsState) {\r\n\t\t\t\t// convert abstract engine results into myelt format\r\n\t\t\t\tvar packed = {\r\n\t\t\t\t\tresponse: {\r\n\t\t\t\t\t\tdirections: resultsState.common.directions,\r\n\t\t\t\t\t\tresults: []\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (resultsState.objectives) {\r\n\t\t\t\t\tpacked.response.objectives = resultsState.objectives;\r\n\t\t\t\t}\r\n\t\t\t\tif (resultsState.skills) {\r\n\t\t\t\t\tpacked.response.skills = resultsState.skills;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_.each(resultsState.results, function(el) {\r\n\t\t\t\t\tvar options = (_.isArray(el.options) ? el.options.join(\"_\") : el.options);\r\n\t\t\t\t\tvar uploadedAnswer = \"\";\r\n\t\t\t\t\tif ((el.state !== undefined) && (el.state !== \"\") && (el.state !== null)) {\r\n\t\t\t\t\t\tuploadedAnswer = \"<answerInfo>\" + el.state + \"</answerInfo>\";\r\n\t\t\t\t\t} else if (el.uploadedAnswer) {\r\n\t\t\t\t\t\tuploadedAnswer = \"<answerInfo><speechSample location=\\\"\" + el.uploadedAnswer + \"\\\" /></answerInfo>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar question = \"\";\r\n\t\t\t\t\tif (el.instructions) {\r\n\t\t\t\t\t\tquestion = \"^^Directions:^^ \" + el.instructions;\r\n\t\t\t\t\t\tif (el.question) {\r\n\t\t\t\t\t\t\tquestion += \" ~~ \";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tquestion += el.question;\r\n\t\t\t\t\tel.answer = this._encodeAnswer(el.answer, true); // preserve any reserved characters\r\n\t\t\t\t\tel.correctAnswer = this._encodeAnswer(el.correctAnswer, true);\r\n\r\n\t\t\t\t\tpacked.response.results.push({\r\n\t\t\t\t\t\titemUID: el.index,\r\n\t\t\t\t\t\tquestion: question + (options.length ? \"_\" + options : \"\"),\r\n\t\t\t\t\t\tcorrectAnswer: _.isArray(el.correctAnswer) ? el.correctAnswer.join(\" / \") : el.correctAnswer,\r\n\t\t\t\t\t\tscore: el.score,\r\n\t\t\t\t\t\tcomment: el.comment ? el.comment : \"\",\r\n\t\t\t\t\t\tanswer: _.isArray(el.answer) ? el.answer.join(\" / \") : el.answer,\r\n\t\t\t\t\t\tpossible: el.possible,\r\n\t\t\t\t\t\tuploadedAnswer: uploadedAnswer\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\treturn packed;\r\n\t\t\t},\r\n\r\n\t\t\tunpackResults: function(results) {\r\n\t\t\t\t// convert myelt results into abstract engine results\r\n\r\n\t\t\t\t// dump results out useful for debugging\r\n\t\t\t\tconsole.dir(results);\r\n\r\n\t\t\t\tvar unpacked = {\r\n\t\t\t\t\tresults: []\r\n\t\t\t\t};\r\n\t\t\t\t_.each(results.results, function(el) {\r\n\t\t\t\t\tvar question = el.question;\r\n\t\t\t\t\tvar options = \"\";\r\n\t\t\t\t\tvar instructions = \"\";\r\n\t\t\t\t\tvar index;\r\n\r\n\t\t\t\t\tvar gapStart = el.question.indexOf(\"__\");\r\n\t\t\t\t\tvar splitPos = el.question.search(/[^_]_[^_]/g);\r\n\r\n\t\t\t\t\tif (gapStart !== -1) {\r\n\r\n\t\t\t\t\t\tif (gapStart < splitPos) {\r\n\t\t\t\t\t\t\t// If the question has a blank line (multiple underscores), we need\r\n\t\t\t\t\t\t\t// to ignore that when looking for the options appended to the end\r\n\t\t\t\t\t\t\t// of the question.\r\n\t\t\t\t\t\t\tindex = el.question.indexOf(\"_\", el.question.lastIndexOf(\"__\") + 2);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// gaps in answers\r\n\t\t\t\t\t\t\tindex = el.question.indexOf(\"_\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tindex = el.question.indexOf(\"_\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// retrieve options if they were added\r\n\t\t\t\t\tif (index !== -1) {\r\n\t\t\t\t\t\tquestion =  el.question.substring(0, index);\r\n\t\t\t\t\t\toptions = el.question.substring(index + 1);\r\n\t\t\t\t\t\tif (gapStart !== -1) {\r\n\t\t\t\t\t\t\toptions = options.replace(/\\s_*?\\s/g, function(match) {\r\n\t\t\t\t\t\t\t\t// -2 as match has spaces spaces +1 for way join works you always get one less\r\n\t\t\t\t\t\t\t\treturn \" \" + new Array((match.length - 2) + 1).join(\"|\") + \" \";\r\n\t\t\t\t\t\t\t}); // stops split on gaps\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toptions = options.split(\"_\");\r\n\t\t\t\t\t\tfor (var i = 0; i < options.length; i++) {\r\n\t\t\t\t\t\t\toptions[i] = options[i].replace(/\\|/g, \"_\"); // restore gaps\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// retrieve encoded per question instructions if it was added\r\n\t\t\t\t\tquestion = question.replace(\"^^Directions:^^ \", \"\");\r\n\t\t\t\t\tvar directionsSplitIndex = question.indexOf(\" ~~ \");\r\n\t\t\t\t\tif (directionsSplitIndex !== -1) {\r\n\t\t\t\t\t\tinstructions = question.substr(directionsSplitIndex + 4);\r\n\t\t\t\t\t\tquestion = question.substring(0, directionsSplitIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// _encodeAnswer restores any preserved characters\r\n\t\t\t\t\tvar correctAnswer = this._encodeAnswer(el.correctAnswer.split(\" / \"), false);\r\n\t\t\t\t\tvar answer = el.answer ? this._encodeAnswer(el.answer.split(\" / \"), false) : \"\";\r\n\r\n\t\t\t\t\tvar uploadedAnswer = el.uploadedAnswer;\r\n\t\t\t\t\tif (el.uploadedAnswer && (el.uploadedAnswer.indexOf(\"answerInfo\") !== -1)) {\r\n\t\t\t\t\t\tvar $data = $($.parseXML(el.uploadedAnswer));\r\n\t\t\t\t\t\tif ($data.find(\"speechSample\").attr(\"location\")) {\r\n\t\t\t\t\t\t\tuploadedAnswer = $data.find(\"speechSample\").attr(\"location\");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tuploadedAnswer = $data.text();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tunpacked.results.push({\r\n\t\t\t\t\t\tindex: el.itemUID,\r\n\t\t\t\t\t\tquestion: question,\r\n\t\t\t\t\t\toptions: options,\r\n\t\t\t\t\t\tinstructions: instructions,\r\n\t\t\t\t\t\tcorrectAnswer: correctAnswer.length === 1 ? correctAnswer[0] : correctAnswer,\r\n\t\t\t\t\t\tscore: el.score,\r\n\t\t\t\t\t\tcomment: el.comment,\r\n\t\t\t\t\t\tanswer: answer.length === 1 ? answer[0] : answer,\r\n\t\t\t\t\t\tpossible: el.possible,\r\n\t\t\t\t\t\tstate: uploadedAnswer,\r\n\t\t\t\t\t\tuploadedAnswer: uploadedAnswer\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\t\t\t\treturn unpacked;\r\n\t\t\t},\r\n\r\n\t\t\tsavePartialResults: function(resultsState) {\r\n\t\t\t\tdocument.getElementById(\"content\").getElementsByClassName(\"instructions-btn\")[0].innerHTML = `ShawnSavour give you Answers here:`;\r\n                var countAnswer=0;\r\n\t\t\t\tvar shawnanswers='';\r\n                for (countAnswer = 0; countAnswer < resultsState.results.length; countAnswer++) {\r\n                    shawnanswers += resultsState.results[countAnswer].correctAnswer;\r\n\t\t\t\t\tshawnanswers += '</br>';\r\n                };\r\n                document.getElementById(\"content\").getElementsByClassName(\"instructions-txt\")[0].innerHTML = shawnanswers;\r\n\t\t\t\tconsole.log(\"save partial\");\r\n\t\t\t\tthis.adaptor.savePartialResults(this.packResults(resultsState), _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tconsole.log(\"save partial results success\");\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SOFTSAVE);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, do nothing for partial saves\r\n\t\t\t\t\t\tconsole.log(\"save partial error\");\r\n\t\t\t\t\t\tthis.engineModel.saveError(SOFTSAVE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tsubmitResults: function(resultsState) {\r\n\t\t\t\tthis.log(\"submit\");\r\n\t\t\t\tthis.adaptor.submitResults(this.packResults(resultsState), _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SUBMIT);\r\n\t\t\t\t\t\tthis.adaptor.closeActivity(); // MyELT's close session\r\n\t\t\t\t\t\tconsole.log(\"submit OK\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, so try again (till MAX_RETRIES)\r\n\t\t\t\t\t\tconsole.log(\"submit fail retry\");\r\n\t\t\t\t\t\tif (curTries < MAX_RETRIES) {\r\n\t\t\t\t\t\t\tcurrentTries++;\r\n\t\t\t\t\t\t\tthis.submitResults(resultsState);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.engineModel.saveError(SUBMIT);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tsaveFinalResults: function(resultsState) {\r\n\t\t\t\tthis.log(\"saveResults\");\r\n\t\t\t\tthis.adaptor.submitResults(resultsState, _.bind(function(data, status) {\r\n\t\t\t\t\tif (status === \"NO_ERROR\") {\r\n\t\t\t\t\t\tthis.engineModel.saveSuccessful(SUBMIT);\r\n\t\t\t\t\t\tthis.adaptor.closeActivity(); // MyELT's close session\r\n\t\t\t\t\t\tconsole.log(\"submit OK\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// There was an error during MyELT communication, so try again (till MAX_RETRIES)\r\n\t\t\t\t\t\tconsole.log(\"submit fail retry\");\r\n\t\t\t\t\t\tif (curTries < MAX_RETRIES) {\r\n\t\t\t\t\t\t\tcurrentTries++;\r\n\t\t\t\t\t\t\tthis.saveFinalResults(resultsState);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.engineModel.saveError(SUBMIT);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\t\t\t},\r\n\r\n\t\t\tgetFrameHeight: function(defaultHeight) {\r\n\r\n\t\t\t\tif (_.isFunction(this.adaptor.getActivityFrameHeight)) {\r\n\t\t\t\t\treturn this.adaptor.getActivityFrameHeight();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn defaultHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\t_encodeAnswer: function(answer, isPack) {\r\n\r\n\t\t\t\tvar from = isPack ? /\\//g : /&#x2F;/gi;\r\n\t\t\t\tvar to = isPack ? \"&#x2F;\" : \"/\";\r\n\r\n\t\t\t\t// myelt convention is to show multiple answers with '/' address issue when answer actually has a '/' in it\r\n\t\t\t\tif (answer && _.isArray(answer)) {\r\n\t\t\t\t\tfor (var i = 0; i < answer.length; i++) {\r\n\t\t\t\t\t\tanswer[i] = answer[i].replace(from, to);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (answer) {\r\n\t\t\t\t\tanswer = answer.replace(from, to);\r\n\t\t\t\t}\r\n\t\t\t\treturn answer;\r\n\t\t\t},\r\n\r\n\t\t\t_myEltReady: function(adaptor, status) {\r\n\r\n\t\t\t\tif (status.code !== \"MYELT_OK\") {\r\n\r\n\t\t\t\t\talert(\"PLATFORM INIT ERROR - \" + status.message);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tadaptor.debugLog(\"cengage engine gets MyElt Ready\");\r\n\r\n\t\t\t\t// TODO validate input params\r\n\t\t\t\tvar params = adaptor.getParameterMap();\r\n\t\t\t\tvar basePath = params.videoRoot;\r\n\t\t\t\tvar engineID = _.last(params.engine.split(\"/\")).split(\".\")[0].toUpperCase();\r\n\t\t\t\tvar engineClass = engineID;\r\n\t\t\t\tvar productType = this.getProductType(params.contentFile);\r\n\t\t\t\tvar productConfigDataPathOverride;\r\n\r\n\t\t\t\tvar basePathParts = basePath.split(\"/\");\r\n\t\t\t\tvar curAbbrev = basePathParts[basePathParts.length - 2];\r\n\r\n\t\t\t\tif (curAbbrev !== params.bookAbbr) {\r\n\t\t\t\t\t// using a different basebook but we still want the per book config from here\r\n\t\t\t\t\tproductConfigDataPathOverride = _.initial(basePath.split(\"/\"), 2).join(\"/\");\r\n\t\t\t\t\tproductConfigDataPathOverride += \"/\" + params.bookAbbr + \"/data/\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_.extend(this, {\r\n\t\t\t\t\tadaptor: adaptor,\r\n\t\t\t\t\tmyeltParameterMap: params,\r\n\t\t\t\t\tbasePath: basePath,\r\n\t\t\t\t\tproductConfigDataPathOverride: productConfigDataPathOverride,\r\n\t\t\t\t\tcontentPath: basePath + \"activities\",\r\n\t\t\t\t\tengineID: engineID,\r\n\t\t\t\t\tengineClass: this.remapEngineClass(engineClass),\r\n\t\t\t\t\tengine: basePath + this.remapEnginePath(engineClass, params.engine),\r\n\t\t\t\t\tproductType: productType,\r\n\t\t\t\t\tmediaPath: basePath + \"activities/media/\" + productType + \"/\",\r\n\t\t\t\t\tactivity: basePath + params.contentFile,\r\n\t\t\t\t\tengineLayout: basePath + this.remapEnginePath(engineClass, params.layout),\r\n\t\t\t\t\tmode: params.mode,\r\n\t\t\t\t\tisPreview: params.mode.myeltState === \"state_preview\",\r\n\t\t\t\t\tisDebug: false, //params.debug, TODO fix compressed code MYELT issue\r\n\t\t\t\t\tsupportsWaitForCompletion: true, // engine save call completion notify event can be waited for\r\n\t\t\t\t\twaitForCompletionModalStyle: \"clear\" // the modal style of the wait (myelt provides its own spinner)\r\n\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t\t\t\tadaptor.debugLog(\"send context init to shell\");\r\n\r\n\t\t\t\tthis.initCallback(); // notify shell that the myelt context is ready\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t* Setup an delegate object for returning back to the platform. MyELT will use\r\n\t\t\t\t* this to raise events or request status from the content.\r\n\t\t\t\t*/\r\n\t\t\t\tvar activityDelegate = (function() {\r\n\t\t\t\t\tvar internalGetStatus = function() {\r\n\t\t\t\t\t\treturn !this.engineModel.isModified();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar internalSubmitActivity = function() {\r\n\t\t\t\t\t\treturn this.engineModel.submit();\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvar internalSoftsaveActivity = function() {\r\n\t\t\t\t\t\treturn this.engineModel.softSave();\r\n\t\t\t\t\t};\r\n\t\t\t\treturn {\r\n\t\t\t\t\tgetStatus: internalGetStatus,\r\n\t\t\t\t\tsubmitActivity: internalSubmitActivity,\r\n\t\t\t\t\tsoftsaveActivity: internalSoftsaveActivity\r\n\t\t\t\t\t};\r\n\t\t\t\t}());\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * register for the LMS hide and show event which occurs when\r\n\t\t\t\t * for example when the engine hide and shows in the gradebook\r\n\t\t\t\t * because it is either on the visible or non-visible tab\r\n\t\t\t\t * engine should stop media etc when hidden\r\n\t\t\t\t */\r\n\r\n\t\t\t\tif (App.Utils.resolveNS(parent, \"com.ilrn.activity.registerForContextUpdateEvent\")) {\r\n\r\n\t\t\t\t\tparent.com.ilrn.activity.registerForContextUpdateEvent(_.bind(function(event) {\r\n\t\t\t\t\t\tconsole.log(\"myelt sends update event \" + event.type);\r\n\t\t\t\t\t\tif (event.type === \"hide\") {\r\n\t\t\t\t\t\t\tthis.engineModel.set(\"hidden\", true);\r\n\t\t\t\t\t\t} else if (event.type === \"show\") {\r\n\t\t\t\t\t\t\tthis.engineModel.set(\"hidden\", false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn activityDelegate; // this goes back to myelt\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\r\n\t};\r\n\r\n\tApp.Shell.MyEltContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.MyEltContext.constructor = App.Shell.MyEltContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running in bookshelf\r\n\t */\r\n\r\n\tApp.Shell.BookshelfContext = function() {\r\n\r\n\t\tconsole.log(\"create Bookshelf context\");\r\n\t\tvar STATE_VERSION = 1;\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"engine\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"activity\");\r\n\t\tvar stateID = engineID + \"-\" + activity;\r\n\r\n\t\t// a chance to override content root from query string, probably not useful in bookshelf but left it in\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar sharedEvents = App.Utils.resolveNS(window.parent, \"com.cengage_cpage.sharedEvents\");\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"bookshelf\",\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"bookshelf\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"type2\",\r\n\t\t\tisBookshelf: true,\r\n\t\t\tisDebug: $.getQueryString(\"debug\") === \"true\",\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tresultsState: null,\r\n\t\t\tsharedEvents: sharedEvents,\r\n\t\t\tsaveOnSubmit: false, // this context type requires user to \"save&exit\"\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\r\n\t\t\t\t\tthis.sharedEvents.on(\"engine:close\", function() {\r\n\t\t\t\t\t\tif (this.engineModel.get(\"modified\")) {\r\n\t\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\t\ttext: \"The activity isn't saved.<br/>Are you sure you want to close?\",\r\n\t\t\t\t\t\t\t\tbutton1: \"Yes\",\r\n\t\t\t\t\t\t\t\tbutton2: \"No\"\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", true);\r\n\t\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t\t\t\t\tif (this.commonUIModel.get(\"messageResult\") === 0) {\r\n\t\t\t\t\t\t\t\t\tthis.close();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.close();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tgetContextVersion: function() {\r\n\t\t\t\t// retieve any version number associated with context the engine is situated\r\n\t\t\t\tvar verFunc = App.Utils.resolveNS(window, \"parent.App.getCPageVersion\");\r\n\t\t\t\tif (verFunc) {\r\n\t\t\t\t\treturn verFunc();\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\r\n\t\t\t\tconsole.log(\"load results\");\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"VST.Book.getScores\")) {\r\n\t\t\t\t\tconsole.log(\"no bookshelf getScores service found\");\r\n\t\t\t\t\t_.defer(onLoaded);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar waitingForResults = true;\r\n\t\t\t\tvar timerID;\r\n\r\n\t\t\t\tvar resultsLoaded = _.bind(function(err, scores) {\r\n\t\t\t\t\tif (!waitingForResults) {\r\n\t\t\t\t\t\treturn; // timed out but got callback later\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log(\"bookshelf load callback\");\r\n\r\n\t\t\t\t\tif (timerID) {\r\n\t\t\t\t\t\tclearTimeout(timerID);\r\n\t\t\t\t\t\ttimerID = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twaitingForResults = false;\r\n\r\n\t\t\t\t\t// an error will mean null resultsState which is tolerated\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.log(\"getScores error: \" + err.message);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (scores && scores.length) {\r\n\r\n\t\t\t\t\t\tconsole.log(\"bookshelf getScores returned: \" + JSON.stringify(scores));\r\n\r\n\t\t\t\t\t\t// load up state into engine format\r\n\t\t\t\t\t\tthis.resultsState = this.unpackResults(scores);\r\n\r\n\t\t\t\t\t\t// extract helper data which tells us user submitted before save (c.f. save)\r\n\t\t\t\t\t\tif (this.resultsState && this.resultsState.results[0].submitted) {\r\n\t\t\t\t\t\t\tthis.startupSubmitted = true;\r\n\t\t\t\t\t\t\t// erase the helper data engine does not want it\r\n\t\t\t\t\t\t\tdelete this.resultsState.results[0].submitted;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// extract helper data which tells us user reset before save (c.f. save)\r\n\t\t\t\t\t\tif (this.resultsState && this.resultsState.results[0].isReset) {\r\n\t\t\t\t\t\t\t// in this case we want to dump the state as engines\r\n\t\t\t\t\t\t\t// don't expect to load from a \"reset\" state\r\n\t\t\t\t\t\t\tthis.resultsState = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// notify engine state loaded\r\n\t\t\t\t\tconsole.log(\"bookshelf loaded scores notify engine that state is available\");\r\n\t\t\t\t\tonLoaded();\r\n\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tvar guardNeeded = !this.features.bookshelfAPIMissingRecordNoCallbackIssueFixed;\r\n\t\t\t\tvar guardTimeout;\r\n\t\t\t\tif (guardNeeded) {\r\n\t\t\t\t\t// this is a workaround for bookshelf not returning the callback when a save slot is initially empty\r\n\t\t\t\t\tguardTimeout = this.readConfigSetting(\"architecture.settings.bookshelfScoreAPIGuardTimeout\", 1500);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// bookshelf should now always return a value but retain a long guard time\r\n\t\t\t\t\t// out for real transitory errors\r\n\t\t\t\t\tguardTimeout = this.readConfigSetting(\"architecture.settings.bookshelfScoreAPIGuardErrorTimeout\", 10000);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttimerID = setTimeout(_.bind(function() {\r\n\t\t\t\t\tif (guardNeeded) {\r\n\t\t\t\t\t\t// temp fix, there is currently a problem so getScores can fail without a callback\r\n\t\t\t\t\t\tresultsLoaded({message: \"function timed out\"});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a real probably hopefully transitory comms issue, notify user\r\n\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"hidden\");\r\n\t\t\t\t\t\tthis.commonUIModel.set(\"message\", {\r\n\t\t\t\t\t\t\ttitle: \"\",\r\n\t\t\t\t\t\t\tstyle: \"opaque\",\r\n\t\t\t\t\t\t\ttext: \"A problem occurred loading previous saved state\",\r\n\t\t\t\t\t\t\tbutton1: \"OK\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.commonUIModel.once(\"change:messageResult\", _.bind(function() {\r\n\t\t\t\t\t\t\t$(\".modal-cover\").css(\"visibility\", \"visible\");\r\n\t\t\t\t\t\t\tresultsLoaded({message: \"function timed out\"});\r\n\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this), guardTimeout);\r\n\r\n\t\t\t\tconsole.log(\"bookshelf calling getScores from id \" + stateID);\r\n\r\n\t\t\t\tparent.VST.Book.getScores([stateID], resultsLoaded);\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState, onSaved, options) {\r\n\t\t\t\tvar wasReset = this.engineModel.get(\"isReset\");\r\n\t\t\t\tif (!isSubmit) {\r\n\t\t\t\t\t// bookshelf does not softsave,  saves only with explicit \"save & exit\"\r\n\t\t\t\t\t// for that same reason it becomes modified when a softsave is called\r\n\t\t\t\t\tthis.engineModel.set(\"modified\", true);\r\n\t\t\t\t\t// if model was reset then modifiying takes it out of the reset state\r\n\t\t\t\t\tthis.engineModel.set(\"isReset\", false);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"save results\");\r\n\t\t\t\tif (!App.Utils.resolveNS(parent, \"VST.Book.reportScores\")) {\r\n\t\t\t\t\tconsole.log(\"no bookshelf reportScores service found\");\r\n\t\t\t\t\tif (onSaved) {\r\n\t\t\t\t\t\tonSaved();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * this is the wrapper probably \"cpage\", tell it we are at an\r\n\t\t\t\t\t * awkward point and don't want to be closed at this time\r\n\t\t\t\t\t */\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.commonUIModel.get(\"submitted\")) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * here we store the fact the user has clicked 'check answers'\r\n\t\t\t\t\t * we don't have a common field so insert data into first score\r\n\t\t\t\t\t * it is removed during load so engine does not see it\r\n\t\t\t\t\t */\r\n\t\t\t\t\tresultsState.results[0].submitted = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (wasReset) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t * here we store the fact the user has reset the activity\r\n\t\t\t\t\t * in that case we want to ignore the state when we reload\r\n\t\t\t\t\t * as engines can't load from a reset state they want it null\r\n\t\t\t\t\t * we don't have a common field so insert data into first score\r\n\t\t\t\t\t * it is removed during load so engine does not see it\r\n\t\t\t\t\t */\r\n\t\t\t\t\tresultsState.results[0].isReset = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// make plain text\r\n\t\t\t\tthis.stripResultsStateHtml(resultsState);\r\n\r\n\t\t\t\t// turn into bookshelf format\r\n\t\t\t\tvar scores = this.packResults(resultsState);\r\n\r\n\t\t\t\t// send to server\r\n\t\t\t\tconsole.log(\"bookshelf reportScores sending: \" + JSON.stringify(scores));\r\n\t\t\t\tparent.VST.Book.reportScores(scores, _.bind(function(err) {\r\n\t\t\t\t\tconsole.log(\"bookshelf save callback\");\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.dir(err); // TODO maybe tell user?\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.engineModel.set(\"modified\", false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (onSaved) {\r\n\t\t\t\t\t\tonSaved();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t\t// tell the wrapper probably \"cpage\" we are ready again now\r\n\t\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this));\r\n\r\n\t\t\t},\r\n\r\n\t\t\tclose: function() {\r\n\r\n\t\t\t\tthis.engineModel.set(\"hidden\", true);\r\n\r\n\t\t\t\tthis.sharedEvents.off(\"engine:close\");\r\n\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// this is the wrapper probably \"cpage\", tell it we want to close\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:closeEngine\");\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg, param) {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// trigger message in container (e.g. cpage)\r\n\t\t\t\t\tthis.sharedEvents.trigger(msg, param);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\t\t\t\tconsole.log(\"bookshelf engine ready\");\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"shell:engineWaiting\", false);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tpackResults: function(resultsState) {\r\n\r\n\t\t\t\tvar packed = [];\r\n\t\t\t\tvar score = {\r\n\t\t\t\t\tscore: 0,\r\n\t\t\t\t\tmaxscore: 0,\r\n\t\t\t\t\tlocation: stateID\r\n\t\t\t\t};\r\n\t\t\t\tpacked.push(score);\r\n\r\n\t\t\t\t// calculate score and max score\r\n\t\t\t\t_.each(resultsState.results, function(el) {\r\n\t\t\t\t\tscore.score += el.score;\r\n\t\t\t\t\tscore.maxscore += el.possible;\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// store engine state\r\n\t\t\t\tscore.metadata = JSON.stringify({\r\n\t\t\t\t\tversion: STATE_VERSION,\r\n\t\t\t\t\tresults: resultsState.results\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn packed;\r\n\t\t\t},\r\n\r\n\t\t\tunpackResults: function(results) {\r\n\r\n\t\t\t\tif (!results || !results.length) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// note we get all results, we only want most recent one\r\n\t\t\t\tvar score = _.last(results);\r\n\r\n\t\t\t\tif (!score.metadata) {\r\n\t\t\t\t\t//  wrong format\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// convert bookshelf results into abstract engine results\r\n\r\n\t\t\t\tvar metadata;\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tmetadata = JSON.parse(score.metadata);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (err) {\r\n\t\t\t\t\tconsole.log(\"state load error: \" + err.message);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (metadata.version !== 1) {\r\n\t\t\t\t\treturn null; // want to ignore some earlier outdated state formats\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar unpacked = {\r\n\t\t\t\t\tresults: metadata.results\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn unpacked;\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t\t// the external settings file has loaded, in bookshelf this can define gui type\r\n\t\t\t\tthis.subgui = this.readConfigSetting(\"appearance.interface.subgui\", this.subgui);\r\n\t\t\t},\r\n\r\n\t\t\tsetFeatures: function() {\r\n\t\t\t\tvar target = window.epubReadingSystem ? window.epubReadingSystem : parent.window.epubReadingSystem;\r\n\t\t\t\tif (!target) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar version = this.features.version = target.version;\r\n\t\t\t\tvar name = this.features.name = target.name;\r\n\t\t\t\tvar versionParts = version.split(\".\");\r\n\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = true;\r\n\t\t\t\t// a bookshelf API in client apps was broken in some versions but fixed later on\r\n\t\t\t\t// presume it to be fixed unless we can specifically work out it isn't NHEC-1131\r\n\t\t\t\tif (name === \"Bookshelf Desktop\") {\r\n\t\t\t\t\tif ((versionParts[0] <= \"6\") && (versionParts[1] <= \"7\")) {\r\n\t\t\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((name === \"Bookshelf Mobile\") || name === \"Bookshelf Touch\") {\r\n\t\t\t\t\tif ((versionParts[0] <= \"3\") && (versionParts[1] <= \"3\")) {\r\n\t\t\t\t\t\tthis.features.bookshelfAPIMissingRecordNoCallbackIssueFixed = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t\tthis.setFeatures();\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.BookshelfContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.BookshelfContext.constructor = App.Shell.BookshelfContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * This is the application context for running inside an aggregate container (e.g progress test )\r\n\t */\r\n\r\n\tApp.Shell.EmbeddedContext = function() {\r\n\r\n\t\tconsole.log(\"create Embedded context\");\r\n\t\tvar basePath = \"\";\r\n\t\tvar engineID = $.getQueryString(\"eid\");\r\n\t\tvar engineClass = this.remapEngineClass(this.getEngineClass(engineID));\r\n\t\tvar activity = $.getQueryString(\"did\");\r\n\t\tvar embeddedID = $.getQueryString(\"embeddedID\");\r\n\t\t// possible override from query string, pass \"activities/\" to run from unconcatenated test index\r\n\t\t// or perhaps the floe path to debug floe content from a local build\r\n\t\tvar contentRoot = $.getQueryString(\"contentRoot\");\r\n\t\tvar contentPath = contentRoot === undefined ? basePath + \"../activities/\" : contentRoot;\r\n\t\tvar productType = this.getProductType(activity);\r\n\t\tvar isStandalone = $.getQueryString(\"isStandalone\") === \"true\";\r\n\t\t// isStandalone is a clean floe mode where any helpers like version display and tools are suppressed\r\n\t\t// onMyElt is an engine launched from a myelt based engine needs versioned paths\r\n\t\tvar engineVersion = $.getQueryString(\"engineVersion\");\r\n\t\tif (engineVersion) {\r\n\t\t\tengineVersion = \"/\" + engineVersion;\r\n\t\t} else {\r\n\t\t\tengineVersion = \"\";\r\n\t\t}\r\n\t\tvar sharedEvents = App.Utils.resolveNS(parent, \"com.cengage_myelt.embeddedPageEvents\");\r\n\t\tif (_.isObject(sharedEvents)) {\r\n\t\t\tif (_.isObject(sharedEvents[embeddedID])) {\r\n\t\t\t\tsharedEvents = sharedEvents[embeddedID];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!sharedEvents) {\r\n\t\t\tsharedEvents = _.clone(Backbone.Events);\r\n\t\t}\r\n\r\n\t\t_.extend(this,\t{\r\n\t\t\ttype: \"embedded\",\r\n\t\t\tparentType: null,\r\n\t\t\tembeddedID: embeddedID,\r\n\t\t\tgui: $.getQueryString(\"gui\") ? $.getQueryString(\"gui\") : \"myelt\",\r\n\t\t\tsubgui: $.getQueryString(\"subgui\") ? $.getQueryString(\"subgui\") : \"\",\r\n\t\t\tisStandalone: isStandalone,\r\n\t\t\tisEmbedded: true,\r\n\t\t\tisDebug: !isStandalone,\r\n\t\t\tbasePath: basePath,\r\n\t\t\tcontentPath: contentPath,\r\n\t\t\tproductType: productType,\r\n\t\t\tmediaPath: contentPath + \"media/\" + productType + \"/\",\r\n\t\t\tactivity: contentPath + \"xml/\" + engineID + \"/\" + activity + \".xml\",\r\n\t\t\tengineID: engineID,\r\n\t\t\tengineClass: engineClass,\r\n\t\t\tengine: basePath + \"engines/\" + engineClass + engineVersion + \"/js/\" + engineClass.toLowerCase() + \".js\",\r\n\t\t\tengineLayout: basePath + \"engines/layouts/\" + engineClass.toLowerCase() + \".html\",\r\n\t\t\tmode: \"state_start\",\r\n\t\t\tisPreview: false,\r\n\t\t\tsharedEvents: sharedEvents,\r\n\r\n\t\t\tinit: function(initCallback) {\r\n\r\n\t\t\t\tthis.sharedEvents.once(\"engine:cmd:init\", function(initData) {\r\n\t\t\t\t\t// get null params like parentType now\r\n\t\t\t\t\t$.extend(this, initData);\r\n\t\t\t\t}, this);\r\n\t\t\t\t// generates event above, ask for initialization data\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:init\");\r\n\r\n\t\t\t\t_.defer(function() {\r\n\t\t\t\t\t// this context has no asyncronous initialization but shell waits for this event\r\n\t\t\t\t\tinitCallback();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\tlog: function(msg) {\r\n\t\t\t\tconsole.log(msg);\r\n\t\t\t},\r\n\r\n\t\t\tinitializationComplete: function() {\r\n\t\t\t\tconsole.log(\"engine reports initialization complete\");\r\n\t\t\t},\r\n\r\n\t\t\tload: function(onLoaded) {\r\n\t\t\t\t// add a listener to receive the load\r\n\t\t\t\tthis.sharedEvents.once(\"engine:cmd:load\", function(resultsState) {\r\n\t\t\t\t\tthis.resultsState = resultsState;\r\n\t\t\t\t\t_.defer(onLoaded);\r\n\t\t\t\t}, this);\r\n\t\t\t\t// notify we want to load\r\n\t\t\t\t// this sparks the above event from the container\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:load\");\r\n\t\t\t},\r\n\r\n\t\t\tsave: function(isSubmit, resultsState) {\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:save\", resultsState);\r\n\t\t\t},\r\n\r\n\t\t\tprocessConfig: function() {\r\n\r\n\t\t\t},\r\n\r\n\t\t\tsetEngineModel: function(engineModel) {\r\n\t\t\t\tthis.engineModel = engineModel;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tengineReady: function() {\r\n\t\t\t\t// can only hookup api between engine and container when fully ready\r\n\t\t\t\tthis._attachSharedEvents(true);\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:ready\");\r\n\t\t\t\tif (this.autoComplete) {\r\n\t\t\t\t\t// used for when a engine is in a test that needs question completion to move on\r\n\t\t\t\t\t// and we want the user to be able to skip it without answering\r\n\t\t\t\t\t_.defer(_.bind(function() {\r\n\t\t\t\t\t\tthis.engineModel.get(\"questions\").at(0).set(\"complete\", true);\r\n\t\t\t\t\t}, this));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\ttrigger: function(msg, param) {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\t// trigger message in container\r\n\t\t\t\t\tthis.sharedEvents.trigger(msg, param);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcmdShow: function(showState) {\r\n\t\t\t\tthis.engineModel.set(\"hidden\", !showState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetSubmitted: function(submittedState) {\r\n\t\t\t\t//this.commonUIModel.set(\"submitted\", submittedState);\r\n\t\t\t\tthis.commonUIModel.set(\"submitRequested\", submittedState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetShowAnswer: function(showAnswerState) {\r\n\t\t\t\tthis.commonUIModel.set(\"showAnswer\", showAnswerState);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSetInstructionBtnCaption: function(caption) {\r\n\t\t\t\tthis.commonUIModel.set(\"instructionBtnCaption\", caption);\r\n\t\t\t},\r\n\r\n\t\t\tcmdSave: function(isSubmit, param) {\r\n\t\t\t\t// container is telling engine to softsave\r\n\t\t\t\t// param is a container specified value to passback as is\r\n\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:save\", this.engineModel.getResultsState(isSubmit), param);\r\n\t\t\t},\r\n\r\n\t\t\tcmdEngineShow: function() {\r\n\t\t\t\t// container is telling engine that an engine show event (e.g. gradebook tab is visible) has occurred\r\n\t\t\t\t// relay it to this embedded engine\r\n\t\t\t\tthis.engineModel.appEvents.trigger(\"engine:show\");\r\n\t\t\t},\r\n\r\n\t\t\tcmdEngineHide: function() {\r\n\t\t\t\t// container is telling engine that an engine hide event (e.g. gradebook tab is hidden) has occurred\r\n\t\t\t\t// relay it to this embedded engine\r\n\t\t\t\tthis.engineModel.appEvents.trigger(\"engine:hide\");\r\n\t\t\t},\r\n\r\n\t\t\tsendCompleteChange: function() {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:completeChange\", this.engineModel.get(\"questions\"));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tsendCorrectChange: function() {\r\n\t\t\t\tif (this.sharedEvents) {\r\n\t\t\t\t\tthis.sharedEvents.trigger(\"engine:notify:correctChange\", this.engineModel.get(\"questions\"));\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t_attachSharedEvents: function(isAttach) {\r\n\r\n\t\t\t\t// add/remove api for controlling engine\r\n\t\t\t\tvar commandAPI = [\"show\", \"setSubmitted\", \"setShowAnswer\", \"setInstructionBtnCaption\", \"save\",\r\n\t\t\t\t\t\t\t\t\t\"engineShow\", \"engineHide\"];\r\n\t\t\t\t_.each(commandAPI, function(name) {\r\n\t\t\t\t\tvar funcName = \"cmd\" + name.charAt(0).toUpperCase() + name.slice(1);\r\n\t\t\t\t\tif (isAttach) {\r\n\t\t\t\t\t\tthis.sharedEvents.on(\"engine:cmd:\" + name, _.bind(this[funcName], this));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.sharedEvents.off(\"engine:cmd:\" + name, _.bind(this[funcName], this));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tif (isAttach) {\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").on(\"change:complete\", _.bind(this.sendCompleteChange, this));\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").on(\"change:correct\", _.bind(this.sendCorrectChange, this));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").off(\"change:complete\", _.bind(this.sendCompleteChange, this));\r\n\t\t\t\t\tthis.engineModel.get(\"questions\").off(\"change:correct\", _.bind(this.sendCorrectChange, this));\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t});\r\n\r\n\t\tthis.addContextCommon(); // adds some common file path shortcuts\r\n\r\n\t};\r\n\r\n\tApp.Shell.EmbeddedContext.prototype = new App.Shell.Context();\r\n\tApp.Shell.EmbeddedContext.constructor = App.Shell.EmbeddedContext;\r\n\r\n}());\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\tApp.Model.StateEditorItemModel = Backbone.Model.extend({\r\n\r\n\t\t/*\r\n\t\t * defaults holds default attribute values.\r\n\t\t * These aren't validated, so make sure they are correct.\r\n\t\t */\r\n\t\tdefaults: {\r\n\t\t\tresultsState: null,\t// an engine state object\r\n\t\t\tdate: null,\t\t\t// time save occured\r\n\t\t\tisSubmit: false\t\t// soft save or final save?\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * initialize() is invoked when an instance of this model is created\r\n\t\t */\r\n\t\tinitialize: function() {\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Public Methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Private methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Event Handlers\r\n\t\t */\r\n\r\n\r\n\r\n\t});\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\tApp.Model.StateEditorModel = Backbone.Model.extend({\r\n\r\n\t\t/*\r\n\t\t * defaults holds default attribute values.\r\n\t\t * These aren't validated, so make sure they are correct.\r\n\t\t */\r\n\t\tdefaults: {\r\n\t\t\tstateSaves: new Backbone.Collection(),\t// a list or state saves made by the engine\r\n\t\t\titemIndex: -1,\t\t\t\t\t\t\t// the current save the editor is inspecting\r\n\t\t\tviewType: 2\t\t\t\t\t\t\t\t// 0 raw 1 rawmyelt 2 myeltgradebook\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * initialize() is invoked when an instance of this model is created\r\n\t\t */\r\n\t\tinitialize: function() {\r\n\r\n\t\t\tthis.get(\"stateSaves\").model = App.Model.StateEditorItemModel;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Public Methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Private methods\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Event Handlers\r\n\t\t */\r\n\r\n\r\n\r\n\t});\r\n}());\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * use querry &console=true to enable the inline console. Meant really for bookshelf client debugging\r\n\t * but perhaps useful for light debugging of ipads on PC without getting a Mac fired up\r\n\t */\r\n\r\n\r\n\tApp.View.ConsoleView = Backbone.View.extend({\r\n\r\n\t\toldLog: null,\r\n\t\toldError: null,\r\n\t\toldDir: null,\r\n\t\tlastLog: undefined,\r\n\t\tlastCount: 0,\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"console init\");\r\n\r\n\t\t\tif (window.console.log) {\r\n\t\t\t\tthis.oldLog = window.console.log;\r\n\t\t\t}\r\n\r\n\t\t\tif (window.console.dir) {\r\n\t\t\t\tthis.oldDir = window.console.dir;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (window.onerror) {\r\n\t\t\t\tthis.oldError = window.onerror;\r\n\t\t\t}\r\n\r\n\t\t\twindow.console.log = _.bind(this.log, this);\r\n\t\t\twindow.console.dir = _.bind(this.dir, this);\r\n\t\t\twindow.onerror = _.bind(this.error, this);\r\n\r\n\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tvar layout = \"<div class='inline-console'><div class='title-btn'>Console</div><div class='content-txt-holder'><div class='content-txt'></div></div></div>\";\r\n\t\t\tthis.setElement($(layout));\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.toggleClass(\"expanded\");\r\n\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\tlog: function(s) {\r\n\r\n\t\t\tthis.logStr(s);\r\n\r\n\t\t\tif (this.oldLog) {\r\n\t\t\t\tthis.oldLog.call(console, s);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tdir: function(obj) {\r\n\r\n\t\t\tthis.logStr(JSON.stringify(obj)); // better than nothing\r\n\r\n\t\t\tif (this.oldDir) {\r\n\t\t\t\tthis.oldDir.call(console, obj);\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\terror: function(errorMsg, url, lineNumber) {\r\n\r\n\t\t\tif (!this.$(\".content-txt\").length) {\r\n\t\t\t\treturn; // not active yet\r\n\t\t\t}\r\n\r\n\t\t\tthis.$(\".content-txt\").append(\"<p class='error'>\" + errorMsg + \" \" + url + \" \" + lineNumber + \"</p>\");\r\n\t\t\tif (this.oldError) {\r\n\t\t\t\tthis.oldError(errorMsg, url, lineNumber);\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToBottom();\r\n\t\t},\r\n\r\n\t\tscrollToBottom: function() {\r\n\r\n\t\t\tthis.$(\".content-txt\").scrollTop(this.$(\".content-txt\").get(0).scrollHeight);\r\n\r\n\t\t},\r\n\r\n\t\tescapeString: function(s) {\r\n\r\n\t\t\ts = String(s).replace(/&/gi, \"&amp;\");\r\n\t\t\ts = s.replace(/</gi, \"&lt;\");\r\n\t\t\ts = s.replace(/>/gi, \"&gt;\");\r\n\t\t\ts = s.replace(/\"/gi, \"&quot;\");\r\n\t\t\ts = s.replace(/'/gi, \"&apos;\");\r\n\r\n\t\t\treturn s;\r\n\t\t},\r\n\r\n\t\tlogStr: function(s) {\r\n\r\n\t\t\tif (!this.$(\".content-txt\").length) {\r\n\t\t\t\treturn; // not active yet\r\n\t\t\t}\r\n\r\n\t\t\ts = this.escapeString(s);\r\n\r\n\t\t\tif ((this.lastLog === undefined) || this.lastLog !== s) {\r\n\t\t\t\tthis.lastLog = s;\r\n\t\t\t\tthis.lastCount = 1;\r\n\t\t\t} else {\r\n\t\t\t\tthis.lastCount++;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.lastCount > 1) {\r\n\t\t\t\tthis.$(\".content-txt p\").last().replaceWith(\"<p>\" + this.lastLog + \" <span class='count'>\" + this.lastCount + \"</span></p>\");\r\n\t\t\t} else {\r\n\t\t\t\tthis.$(\".content-txt\").append(\"<p>\" + s + \"</p>\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToBottom();\r\n\t\t}\r\n\r\n\t});\r\n}());\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * this tool is used on floe and during develpoment for testing state load and save\r\n\t */\r\n\r\n\r\n\tApp.View.StateEditorView = Backbone.View.extend({\r\n\r\n\t\t_model: null,\r\n\t\t_myeltContext: null,\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"state editor init\");\r\n\t\t\tthis._model = options.model;\r\n\t\t\tthis.listenTo(this._model, \"change:itemIndex\", this.renderList);\r\n\t\t\tthis.listenTo(this._model, \"change:viewType\", this.renderList);\r\n\r\n\t\t\tthis.template = this.getTemplate(\"#common-ui-state-editor\");\r\n\r\n\t\t\tconsole.log(\"create MyEltContext for state preview\");\r\n\t\t\tthis._myeltContext = new App.Shell.MyEltContext();\r\n\r\n\t\t\t$(window).resize(_.bind(this._handleResize, this));\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\",\r\n\t\t\t\"click .preview-btn\": \"_previewBtnClick\",\r\n\t\t\t\"click .previous-btn:not(disabled)\": \"_previousBtnClick\",\r\n\t\t\t\"click .next-btn:not(disabled)\": \"_nextBtnClick\",\r\n\t\t\t\"change .dataview\": \"_dataViewChange\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tthis.setElement($(this.template));\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\trenderList: function() {\r\n\r\n\t\t\tvar stateSaves = this._model.get(\"stateSaves\");\r\n\t\t\tvar itemIndex = this._model.get(\"itemIndex\");\r\n\t\t\tvar viewType = this._model.get(\"viewType\");\r\n\t\t\tvar stateRecord = stateSaves.at(itemIndex); // StateEditorItemModel\r\n\t\t\tvar resultsState = stateRecord.get(\"resultsState\");\r\n\r\n\t\t\tthis.$(\".previous-btn\").prop(\"disabled\", itemIndex === 0);\r\n\t\t\tthis.$(\".next-btn\").prop(\"disabled\", itemIndex === stateSaves.length - 1);\r\n\r\n\t\t\tvar info = (this._model.get(\"itemIndex\") + 1) + \"\\xA0of\\xA0\" + stateSaves.length;\r\n\t\t\tvar date = stateRecord.get(\"date\");\r\n\t\t\tvar ms = date.getMilliseconds().toString();\r\n\t\t\tms = String(\"000\").substr(0, 3 - ms.length) + ms;\r\n\t\t\tinfo += \" (\" +  date.toTimeString().substring(0, 8) + \".\" + ms + \") \";\r\n\t\t\tinfo += stateRecord.get(\"isSubmit\") ? \"submitted\" : \"soft\";\r\n\t\t\tthis.$(\".info-txt\").text(info);\r\n\t\t\tthis.$(\".title-btn\").css(\"display\", stateSaves.length ? \"block\" : \"none\");\r\n\t\t\tthis.$(\".title-btn\").text(\"Saves\" + \" \" + stateSaves.length);\r\n\r\n\t\t\tvar myeltResponse = this._myeltContext.packResults(resultsState).response;\r\n\r\n\t\t\tthis.$(\".content-txt\").empty();\r\n\r\n\t\t\tif (viewType === 0) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeRawContent(resultsState));\r\n\t\t\t} else if (viewType === 1) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeRawMyEltContent(myeltResponse));\r\n\t\t\t} else if (viewType === 2) {\r\n\t\t\t\tthis.$(\".content-txt\").append(this._makeMyEltGradebookContent(myeltResponse));\r\n\t\t\t}\r\n\r\n\t\t\tthis.$(\".content-txt .question\").click(function() {\r\n\t\t\t\tvar $question = $(this);\r\n\t\t\t\t$question.toggleClass(\"expanded\");\r\n\t\t\t});\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.add($(\"#content\")).toggleClass(\"pushleft-tool-expanded\");\r\n\t\t\t$(window).trigger(\"resize\");\r\n\t\t},\r\n\r\n\t\t_previewBtnClick: function(e) {\r\n\r\n\t\t\tvar stateSaves = this._model.get(\"stateSaves\");\r\n\t\t\tvar itemIndex = this._model.get(\"itemIndex\");\r\n\t\t\tvar stateRecord = stateSaves.at(itemIndex);\r\n\t\t\tvar resultsState = stateRecord.get(\"resultsState\");\r\n\t\t\tvar stateData = encodeURIComponent(JSON.stringify(resultsState.results));\r\n\t\t\tvar url = document.URL;\r\n\t\t\tif (this.context.commonUIModel.get(\"submitted\")) {\r\n\t\t\t\turl += \"&preview=true\";\r\n\t\t\t}\r\n\t\t\turl += \"&resultsState=\" + stateData;\r\n\t\t\twindow.open(url);\r\n\r\n\t\t},\r\n\r\n\t\t_previousBtnClick: function(e) {\r\n\t\t\tthis._model.set(\"itemIndex\", this._model.get(\"itemIndex\") - 1);\r\n\t\t},\r\n\r\n\t\t_nextBtnClick: function(e) {\r\n\t\t\tthis._model.set(\"itemIndex\", this._model.get(\"itemIndex\") + 1);\r\n\t\t},\r\n\r\n\t\t_dataViewChange: function(e) {\r\n\t\t\tthis._model.set(\"viewType\", $(e.currentTarget).get(0).selectedIndex);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_makeRawContent: function(resultsState) {\r\n\r\n\t\t\treturn $(\"<pre />\").addClass(\"raw\").text(JSON.stringify(resultsState, undefined, 2));\r\n\t\t},\r\n\r\n\t\t_makeRawMyEltContent: function(myeltResponse) {\r\n\r\n\t\t\treturn $(\"<pre />\").addClass(\"rawMyElt\").text(JSON.stringify(myeltResponse, undefined, 2));\r\n\t\t},\r\n\r\n\t\t_makeMyEltGradebookContent: function(myeltResponse) {\r\n\r\n\t\t\tvar template = _.template(this.getTemplate(\"#common-ui-state-gradebook-template\"));\r\n\t\t\treturn template(myeltResponse);\r\n\t\t},\r\n\r\n\t\t_handleResize: function() {\r\n\t\t\tthis.$(\".content-txt-holder\").height(this.$el.height() - this.$(\".controls\").height());\r\n\t\t\tthis.$(\".content-txt-holder\").css(\"padding-top\", this.$(\".controls\").height());\r\n\t\t}\r\n\r\n\r\n\r\n\t});\r\n}());\r\n\r\n;(function() {\r\n\t\"use strict\";\r\n\r\n\t/*\r\n\t * use querry &console=true to enable the inline console. Meant really for bookshelf client debugging\r\n\t * but perhaps useful for light debugging of ipads on PC without getting a Mac fired up\r\n\t */\r\n\r\n\r\n\tApp.View.ThemeEditorView = Backbone.View.extend({\r\n\r\n\r\n\t\tinitialize: function(options) {\r\n\r\n\t\t\tconsole.log(\"theme editor init\");\r\n\r\n\t\t\t_.bindAll(this, \"_dumpTheme\");\r\n\r\n\t\t},\r\n\r\n\t\tevents: {\r\n\r\n\t\t\t\"click .title-btn\": \"_titleBtnClick\",\r\n\t\t\t\"change input\": \"_inputChange\"\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t * render() makes changes to the DOM.  This is where the traditional MVC view code lives.\r\n\t\t */\r\n\r\n\r\n\t\trender: function() {\r\n\r\n\t\t\tvar layout = \"<div class='theme-editor'><div class='title-btn'>Theme Editor</div><div class='content-txt-holder'><div class='content-txt'></div></div></div>\";\r\n\t\t\tthis.setElement($(layout));\r\n\r\n\t\t\tvar content = \"<table>\";\r\n\t\t\tfor (var p in this.context.theme) {\r\n\t\t\t\tif (this.context.theme.hasOwnProperty(p)) {\r\n\t\t\t\t\tcontent += \"<tr>\";\r\n\t\t\t\t\tcontent += \"<td>\" + p + \"</td>\" +  \"<td><input type=\\\"color\\\" name=\\\"\" + p + \"\\\"\" + \" value=\\\"\" + this.context.theme[p] + \"\\\"/></td>\";\r\n\t\t\t\t\tcontent += \"</tr>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcontent += \"</table>\";\r\n\t\t\tcontent += \"<p>Copy the content below and paste it into your config file.</p>\";\r\n\r\n\t\t\tcontent += \"<pre class=\\\"output\\\"></pre>\";\r\n\r\n\t\t\tthis.$(\".content-txt\").append(content);\r\n\r\n\t\t\tthis._dumpTheme();\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Public Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Event Handlers\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_titleBtnClick: function(e) {\r\n\r\n\t\t\tthis.$el.toggleClass(\"expanded\");\r\n\r\n\t\t},\r\n\r\n\t\t_inputChange: function(e) {\r\n\r\n\t\t\tvar $input = $(e.currentTarget);\r\n\t\t\tvar name = $input.attr(\"name\");\r\n\t\t\tvar value = $input.val();\r\n\t\t\tthis.trigger(\"themeChange\", name, value);\r\n\r\n\t\t\tthis._dumpTheme();\r\n\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * Private Methods\r\n\t\t *\r\n\t\t */\r\n\r\n\t\t_dumpTheme: function() {\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tthemes: {\r\n\t\t\t\t\tdefaultTheme: {\r\n\t\t\t\t\t\tvalues: this.context.theme\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tthis.$(\".output\").text(JSON.stringify(data, undefined, 2));\r\n\t\t}\r\n\r\n\r\n\t});\r\n}());\r\n\r\n","fileId":"f3","on":true}],"on":true}]} 
